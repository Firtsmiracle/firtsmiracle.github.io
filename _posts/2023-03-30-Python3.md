---
layout      : post 
title       : "aprende Python desde cero a avanzado curso completo"
author      : Firtsmiracle
image       : assets/images/articles/2023-03-30-Python3/py.png
category    : [ articulos ]
tags        : [ Python3, programacion ]
---

En esta ocasion hablaremos del lenguaje de programacion Python3, realizaremos todo un curso completo desde lo mas basico y explicaremos todo lo escencial para que se pueda llegar a dominar este lenguaje.

> El articulo se ira actualizando constantemente

# Que es Python3?

Python3 es un lenguaje de programación ampliamente utilizado en las aplicaciones web, el desarrollo de software, la ciencia de datos y el machine learning. Es preferido entre los desarrolladores porque es eficiente y fácil de aprender, además de que se puede ejecutar en muchas plataformas diferentes, se integra bien a todos los tipos de sistemas y aumenta la velocidad del desarrollo. El software podemos descargarlo gratis de su pagina oficial.


## Indice y Estructura

- [Que es Python3](#que-es-Python3?)
-  [Sintaxis](#sintaxis)
- [Variables](#variables)
    * [Tipos de Variables](#tipos-de-variables) 
    * [Asignación Multiple de Variables](#asignación-multiple-de-variables) 
    * [Sintaxis de Variables](#sintaxis-de-variables)
- [Strings](#strings)
    * [Indexación](#indexación)
    * [Slicing](#slicing)
    * [Stride](#stride)
    * [Modificación de Strings](#modificación-de-strings)
    * [Strings de multiples lineas](#strings-de-multiples-lineas)
- [Numeros](#numeros)
    * [Numeros Enteros](#numeros-enteros)
    * [Numeros Flotantes](#numeros-flotantes)
    * [Numeros Complejos](#numeros-complejos)

- [Comentarios](#comentarios)
    * [Comentarios de Varias Lineas](#comentarios-de-varias-lineas)
- [Operadores Aritmeticos](#operadores-aritmeticos)
    * [Suma y Resta](#suma-y-resta)
        * [Sumar y restar datos Numericos](#sumar-y-restar-datos-numericos)
        * [Sumar y restar datos Strings](#sumar-y-restar-datos-strings)
    * [Multiplicación y División](#multiplicación-y-división)
        * [Multiplicar y dividir datos Numericos](#multiplicar-y-dividir-datos-numericos)
        * [Multiplicar y dividir datos Strings](#multiplicar-y-dividir-datos-strings)
    * [Modulo](#modulo)
    * [Exponencial](#exponencial)
    * [Division Entera](#division-entera)
- [Operadores de Asignación](#operadores-de-asignación)
- [Booleanos](#booleanos)
- [Operadores de Comparación](#operadores-de-comparación)
    *  [Comparación entre datos numericos](#comparación-entre-datos-numericos)
    *  [Comparación entre datos strings](#comparación-entre-datos-strings)
- [Operadores de Identidad](#operadores-de-identidad)
- [Operadores de Pertenencia](#operadores-de-pertenencia)
- [Operadores Logicos](#operadores-logicos)
    * [Operador not](#operador-not)
    * [Operador or](#operador-or)
    * [Operador and](#operador-and)
- [Listas](#listas)
    * [Acceso a elementos de una lista](#acceso-a-elementos-de-una-lista)
    * [Operaciones con listas](#operaciones-con-listas)
    * [Listas anidadas](#listas-anidadas)
    * [Las listas son mutables](#las-listas-son-mutables)




# Sintaxis [#](#sintaxis) {#sintaxis}

Cuando hablamos de la sintaxis en Python3, nos referimos como en todo lenguaje al correcto uso y orden de las palabras que utilizamos para comunicarnos. Por ello, en Python3 también es necesario cumplir ciertos requisitos a la hora de expresarnos.

Comenzaremos con la sintaxis tipica que nos ayuda a imprimir los valores concretamente su nombre es `print` que viene a ser una funcion interna de Python que recibe una variable o tipo de dato y nos lo muestra por pantalla, por ahora solo hay que tener presente el concepto de `print` ya que mas adelante profundizaremos en los demas conceptos que nos ayudaran a comprender mejor como funciona este lenguaje.

```python
print("Hola Python3")

Hola Python3
```

# Variables [#](#variables) {#variables}


Una variable es un elemento de un lenguaje de programación que tiene asignado un valor determinado. Para crear una variable en Python3 debemos proporcionarle un nombre y asignarle un valor utilizando el símbolo `=`.

```python
variable = "Hola Python3"

print(variable)

Hola Python3
```

Ahora el valor asignado a la variable puede cambiar a lo largo del codigo a otra difierente.

```python
variable = "Hola Python3"

print(variable)

Hola Python3

variable2 = "Adios Python3"

print(variable)

Adios Python3
```

## Tipos de Variables

Existen 4 tipos de variables principales o primitivas en Python3, concretamente estas son:

Tipo`int`: Para representar numeros enteros.
Tipo `string`: Para representar texto o cadenas.
Tipo `boolean`: Para representar datos binarios, es decir que pueden tomar los valores `True` o `False`.
Tipo `float`: Para representar numeros con decimales.

| Representacion |Tipo  |
| ------ | -------- | 
|numeros enteros    | int      | 
| cadenas de texo   | string     | 
| numeros decimales   | float |
| dato binario(True o False)   | boolean |


Definimos un conjunto de variables segun su tipo y usamos la funcion reservada de python `type()` para ver el tipo de variable segun su asignacion:

```python
variable1 = 10

variable4 = 2.4

variable2 = "Hola Python"

variable3 = True

variable4 = 2.4

type(variable1)

int

type(variable2)

str

type(variable3)

bool

type(variable4)

float
```

## Asignación Multiple de Variables

En Python3 podemos asignar una variable a otra variable diferente.

```python
variable = "Hola Python3"

variable2 = variable

print(variable2)

Hola Python3
```

## Sintaxis de Variables

En Python3 se debe cumplir con las reglas sintácticas definidas por el leguaje. A continuación indicamos las reglas que debemos cumplir cuando definimos el nombre de una variable:

 * Las variables en Python3 pueden tener cualquier longitud y pueden consistir en letras mayúsculas y minúsculas `A-Z, a-z`, dígitos del `0-9` y el carácter de subrayado o subguion `_`


```python
_variable = "Hola Python3"

print(_variable)

Hola Python3

vAriAbLe = "Hola Python3"

print(vAriAbLe)

Hola Python3

variable_1_1 = "Hola Python3"

print(variable_1_1)

Hola Python3
```

 * Si no se cumple con las reglas definidas de sintaxys, emitiran un error

  ```python
  variable$ = "Hola Python3"

    File "<iPython3-input-12-f520f3dd0eb3>", line 1
      variable$ = "Hola Python3"
         ^
  SyntaxError: invalid syntax
  ```

 * El nombre de una variable puede contener dígitos, pero el primer caracter de un nombre de variable no puede ser un dígito. 
  
  ```python
  1variable = "Hola Python3"

    File "<iPython3-input-13-905ee4ad3fed>", line 1
      1variable = "Hola Python3"
     ^
  SyntaxError: invalid syntax
  ```
   * El nombre de las variables en Python3 es sensible a mayúsculas y minúsculas

   ```python
   Variable1 = "Hola Python3"

   print(variable1)

   ---------------------------------------------------------------------------
   NameError                                 Traceback (most recent call last)
   <iPython3-input-15-32693f267891> in <module>
   ----> 1 print(variable1)

   NameError: name 'variable1' is not defined
   ```

# Strings [#](#Strings) {#Strings}


Un string se corresponde con un conjunto de caracteres que forman una cadena de texto.

La sintaxis que debemos utilizar para definir strings en Python consiste en situar los caracteres entre `" o '`


```python
variable1 = "Esto es mi primer string"

variable2 = 'Esto es mi segunda string'
```

La flexibilidad de definir `string` con el caracter " y el caracter ' nos permite definir cadenas de texto que contienen esos mismos caracteres.

```python
variable1 = 'Los tipos strings pueden definirse con el caracter "'

variable2 = "Los tipos strings pueden definirse con el caracter '"

print(variable1)

Los strings pueden definirse con el caracter "

print(variable2)

Los strings pueden definirse con el caracter '
```

## Indexación

En muchos tipos de datos en Python3 se puede acceder a los elementos individuales de un conjunto de datos directamente mediante un índice numérico o un valor clave. Este proceso se denomina `indexación`.

En Python3, las cadenas son secuencias ordenadas de caracteres, y por lo tanto pueden ser indexadas de esta manera. Se puede acceder a los caracteres individuales de una cadena especificando el nombre de la cadena seguido de un número entre corchetes `[]`.

El primer carácter de la cadena tendra el índice 0, el siguiente el índice 1, y así sucesivamente. El índice del último carácter será la longitud de la cadena menos uno.

```python
lenguaje = "Python"

lenguaje[0]

'P'

lenguaje[2]

't'
```

Podemos tambien utilizar números negativos para extraer los caracteres por el final de la cadena de texto, donde `-1` seria la parte final y asi sucesivamente de derecha a izquierda.

```python
lenguaje[-1]

'n'

lenguaje[-3]

'h'
```

## Slicing

Python3 permite una sintaxis específica de indexación que extrae subcadenas de una cadena de texto, a esto se denomina '`slicing`.

La sintaxis que se utiliza para extraer una subcadena de una cadena de nombre `micadena` es de la forma `micadena[x:y]`, esto devuelve la parte de la cadena `micadena` que comienza en la posición `x`,y termina en la posición `y`; con la exepción de que no se incluye el último caracter.

```python
lenguaje = "Hola Python"

lenguaje[0:4]

'Hola'

lenguaje[-6:-1]

'Pytho'
```
Podemos observar que efectivamente no se incluye el ultimo caracter que se especifica: `ojo tener en cuenta que los espacios tambien son caracteres correspondientes a una cadena vacia` 


Pero que pasaria entonces si no indicamos uno de los numeros:

```python
lenguaje = "Hola Python"

lenguaje[-6:]

'Python'

lenguaje[5:]

'Python'
```

Si no indicamos alguno de los numeros lo que hace Python3 es leer hasta el final.


## Stride

Es una variante más del slicing. Si se añade un : adicional y un tercer índice, se designa una stride, que indica cuantos caracteres saltar hasta obtener el siguiente caracter.

Este salto lo hara contando el propio caracter.

```python
lenguaje = "Hola Python"

lenguaje[0:4:2]

'Hl'

lenguaje[0:4:1]

'Hola'

nombre[0:8:3]

'ha'
```

## Modificación de Strings

Una string es un tipo de dato que en Python3 se considera `inmutable`, esto quiere decir que no podemos modificar una parte de un string asociada a una variable

```python
lenguaje = "Python"

lenguaje[2]

't'

lenguaje[2] = 'a'

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-37-3f77b4874756> in <module>
----> 1 lenguaje[2] = 'a'

TypeError: 'str' object does not support item assignment
```

Pero a pesar de no poderse modificar el contenido de una string, si se puede asignar un string diferente a la variable.

```python
lenguaje = "golang"

print(lenguaje)

golang
```

## Strings de multiples lineas

Si en alguna ocasion queremos definir `strings` de varias lineas podemos hacerlo de varias formas en Python3

Una de ellas seria introducir el caracter `\n` en la posicion de la cadena donde queremos que realize el salto de linea

```python
lenguaje = "Mi\nlenguaje\nfavorito\nes\nPython"

print(lenguaje)
Mi
lenguaje
favorito
es
Python
```

Otra opción tambien podria usar los caracteres `"""`

```python
lenguaje = """Mi
lenguaje
favorito
es
Python
"""

print(lenguaje)
Mi
lenguaje
favorito
es
Python
```

# Numeros

Existen 3 tipos de datos numéricos: enteros `int`, números de punto flotante `float` y números complejos.

## Numeros Enteros

Los números enteros son aquellos que no tienen parte decimal. En Python3 se referencian con la palabra `int`.

```python
num = 10
```
No olvidemos que es muy importante la diferencia de un número entero y una cadena de texto que representa un número entero.

```python
num = 10
num = "10"
```

Podemos convertir una cadena de texto que representa un número entero en un valor numérico utilizando la función `int()`

```python
numero = "10"

print(numero)

'10'

numero2 = int(numero)

print(numero2)

10
```

Para separar algunos dígitos para que sea más facil de leer. No podemos usar el `.` o `,` , para esto Python3 nos da la opcion de usar `_`:

```python
numero = 5000000

print(numero)

5000000

numero2 = 5_000_000

print(numero2)

5000000
```

No hay límite en el tamaño de los números enteros que podemos definir, ya que se pueden definir números enteros tan grandes como la memoria de nuestro sistema soporte.

```python
numero = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

print(numero)

100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

## Numeros Flotantes

Los números flotantes son aquellos que tienen una parte decimal, en `Python3` se referencian con la palabra `float`.

```python
numero = 10.5
```
De igual manera que con los números enteros, se puede convertir una cadena de texto que representa un número flotante a un valor numérico utilizando la función `float()`

```python
numero = "12.4"

print(numero)

'12.4'

numero2 = float(numero)

print(numero2)

12.4
```

Existen tres formas de representarlos en Python3.

```python
numero1 = 1000.0

numero2 = 1_000.0

numero3 = 1e3

print(numero1)

1000.0

print(numero2)

1000.0

print(numero3)

1000.0
```

A diferencia que los números enteros, los número de flotantes si tienen un tamaño máximo en Python3. Aunque el tamaño máximo dependera de nuestro sistema, las cifras cercanas o mayores a `2e400` que equivale a `(2x10)^400` suelen superar el tamaño máximo.

```python
numero = 2e400

print(numero)

inf
```
Python3 devuelve `inf` haciendo referencia a infinito.


## Numeros complejos


Hay pocos lenguajes de programacion que ofrecen soporte integrado para números complejos y Python3 es uno de ellos. Aunque los números complejos no suelen aparecer fuera de los dominios de la computación científica, pueden ser de gran utilidad en dominios que usen técnicas estadísticas.

Un número complejo esta formado por 2 componentes distintos: una parte real y una parte imaginaria. 

En Python3 podemos definir un numero complejo, se define la parte real seguida de un símbolo + y la parte imaginaria terminando con la letra j.

```python
numero = 2 + 4j

print(numero)

(2+4j)

numero.real

2.0

numero.imag

4.0
```

# Comentarios [#](#comentarios) {#comentarios}

Los comentarios son parte fundamental en cualquier lenguaje de programación. Permiten describir partes del código que desarrollamos de manera que sea mucho más facil de comprender. Poner comentarios en nuestro código es una muy buena práctica que debemos realizar.


La manera más simple de poner comentarios en Python3 es utilizando el símbolo `#`

```python
# Este es mi comentario
```

Podemos hacer lo mismo despues de escribir una sentencia en nuestro codigo haciendo referencia al significado de esta:

```python
variable = "Hola Python3" # Esto es una variable
```

## Comentarios de varias lineas

Hay ocasiones en que necesitemos poner comentarios de varias líneas. Python3 no permite crear un comentario de varias líneas utilizando el mismo símbolo #.

```python
# Este comentario
# tiene varias lineas
# para mi ejemplo en Python3
```

Existe una manera mas sencilla y comoda de hacer comentarios en Python3 con el uso de `""" todo el comentario """`.

```python
"""
Este comentario
tiene varias líneas
para mi ejemplo en Python3
"""
```

# Operadores Aritmeticos [#](#operadores-aritmeticos) {#operadores-aritmeticos}


A continuación se muestran los operadores aritméticos soportados por Python3:

| Operador | Significado | 
| ------ | -------- | 
|a + b    | suma      | 
| a - b   | resta     | 
| a * b   | multiplicacion |
|a / b    | division |
| a % b   | modulo |
| a // b  | division de enteros |
| a ** b  | exponencial |


## Suma y Resta

Los operadores suma `+`y resta `-` se pueden aplicar a distintos tipos de datos.

### Sumar y restar datos numericos

Al sumar o restar tipos de datos numericos obtenemos el resultado matematico.

```python
numero1 = 10

numero2 = 8

print(numero1 + numero2)

18

print(numero1 - numero2)

8

print(numero2 - numero1)

-2

numero3 = 2.5

numero4 = 1.5

print(numero3 + numero4)

4.0

print(numero3 - numero4)

1.0
```
    
### Sumar y restar datos strings

Cuando sumamos tipos de datos strings se concatenan las variables.

```python
texto1 = "Hola"

texto2 = "Python"

print(texto1 + texto2)

'HolaPython'
```
Si queremos agregar un espacio, debemos agregar una cadena vacia `" "`, sin embargo no podemos restar dichas cadenas.

```python
print(text1 + " " + text2)

'Hola Python'

print(texto1 - texto2)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-16-ed11b0c86524> in <module>
----> 1 texto1 - texto2

TypeError: unsupported operand type(s) for -: 'str' and 'str'
```

## Multiplicación y División

Los operadores de multiplicacion `*` y division `/` son operadores binarios que pueden aplicarse sobre distintos tipos de datos.

### multiplicar y dividir datos numericos

```python
numero1 = 20

numero2 = 4

numero1 * numero2

80

# IMPORTANTE: El resultado al dividir siempre es un float

print(numero1 / numero2)

5.0
```

### multiplicar y dividir datos strings

No podemos multiplicar o dividir cadenas de texto.

```python
texto1 = "Hola"

texto2 = "Python"

texto1 * texto2

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-21-4d766fa04d9a> in <module>
----> 1 texto1 * texto2

TypeError: can't multiply sequence by non-int of type 'str'

print(texto1 / texto2)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-22-7ba20b66d6c5> in <module>
----> 1 texto1 / texto2

TypeError: unsupported operand type(s) for /: 'str' and 'str'
```

Pero si podemos multiplicar una cadena de texto por un numero entero, que imprime el numero de veces de la cadena segun el que numero por el que multiplicamos.

```python
texto1 * 3

'HolaHolaHola'
```
## Modulo

El operador modulo `%` es un operador binario que devuelve el resto de una división entre tipos de datos numericos ya sean enteros o flotantes.

```python
numero1 = 10

numero2 = 7

print(numero1 % numero2)

3

print(numero2 % numero1)

7

numero1 = 10.5

numero2 = 7.2

print(numero1 % numero2)

3.3
```

## Exponencial

El operador exponencial `**` es un operador binario que se aplica solo en tipos de datos numéricos.

```python
numero1 = 5

numero1 ** 2

25

numero ** 3

125

texto1 = "Hola Python"

texto1 ** 2

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-33-a3cd4ee7680f> in <module>
----> 1 texto1 ** 2

TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
```
## Division Entera

El operador divison entera `//`es un operador binario que se aplica sobre tipos de datos numéricos y devuelve la parte entera del resultado.

```python
numero1 = 10

numero2 = 7

print(numero1 / numero2)

1.4285714285714286

print(numero1 // numero2)

1
```

# Operadores de Asignación [#](#operadores-de-asignación) {#operadores-de-asignación}



Anteriormente ya hemos usado el operador de asignación `=` para asignar un valor a una variable.

Sin embargo Python3 nos proporciona un mecanismo para combinar operadores aritméticos y operadores de asignación simplificando nuestro codigo. Esa combinación se denomina `Augmented Assignment`.


| Operador |           |Significado| 
| ---------|-----------| --------- | 
|a += 4    | es igual a |a = a + 4| 
| a -= 8   | es igual a |a = a - 8 | 
| a *= 10  | es igual a |a = a * 10|
|a /= 5    | es igual a |a = a / 5  |



Veamos unos ejemplos:

```python
numero = 15

numero += 5

print(numero)

20

numero2 = 20

numero2 *= 2

print(numero2)

40

numero3 = 8

numero3 -= 3

print(numero3)

5
```
# Booleanos [#](#booleanos) {#booleanos}


Los tipos de datos Boolenos en Python se representan con el tipo `bool` y reciben únicamente dos posibles valores:

- True
- Fase

```python
variable = True

print(variable)

True
```

Podemos usar la funcion reservada `type` para ver el tipo de variable

```python
variable = True

type(varaible)

bool

variable2 = False

type(variable2)

bool
```

Una cosa a tener en cuenta es que las palabras `True` y `False` son palabras reservadas dentro de Python3 y no se les puede asignar ningún valor.

```python
True = "Hola Python"

  File "<ipython-input-7-31dbcec71c48>", line 1
    True = "Hola Python"
    ^
SyntaxError: cannot assign to True
```

# Operadores de Comparación [#](#operadores-de-comparación) {#operadores-de-comparación}


Son los que evalúan la relación que existe entre dos valores en Python. Existen diferentes tipos:


|Operador| 	Ejemplo| 	Significado|
|--------|--------|------------|
|==|	a == b| 	Igual a|
|!=| 	a != b| 	No igual a|
|<| 	a < b| 	Menor que|
|<= |	a <= b| 	Menor que o igual a|
|> |	a > b| 	Mayor que|
|>= |	a >= b| 	Mayor que o igual a|


### Comparación entre datos numericos

A continacion veremos algunos ejemplos

```python
numero1 = 4

numero2 = 8

numero1 == 4

True

numero1 == numero2

False

numero1 == 4.0

True

numero1 != 4

False

numero1 != numero2

True
```
Otros ejemplos

```python
numero1 = 10

numero2 = 15

numero1 < numero2

True

numero2 < numero1

False

numero1 <= 10.0

True
```

### Comparación entre datos strings

```python
texto1 = "cadena de texto"

texto2 = "cadena de texto 2"

texto1 == "cadena de texto"

True

text1 == text2

False

text1 != text2

True
```

Ahora veamos un tipo de comparación mas inusual

```python
texto1 = "Cadena de mi texto"

texto2 = "texto"

texto1 < texto2

True
```

Podemos ver algo muy extraño 

> Esta comparación utiliza un orden lexicográfico: primero se comparan los dos primeros elementos, y si estos son diferentes, determina el resultado de la comparación; si son iguales, se comparan los dos siguientes elementos, y así sucesivamente, hasta que se agote cualquiera de las dos secuencias.


y ahora se preguntaran si segun el principio tenemos arriba como primer caracter de `texto1 -> C` y de `texto2 -> t` como entonces lo esta haciendo?


Pues esto es por la sencilla razon de que esta comparacion lo realiza utilizando los equivalentes numericos de cada caracter, esto mediante la funcion reservada `ord()`que recibe un caracter y se encarga de transformar un caracter a codigo unicode.


Veamoslo mejor con el ejemplo anterior:

```python
#texto1 = "Cadena de mi texto"
#texto2 = "texto"
#condicion texto1 < texto2

"Cadena de mi texto" < "texto"

True

#Cojemos los primeros caracteres de ambas variables y les aplicamos la funcion ord()

ord('C')

67

ord('t')

116

#tendriamos que C = 67 y t = 116

67 < 116

True
```
Despues de analizar el ejemplo anterior, efectivamente vemos que la condicion era cierta y ahora nos queda claro como es que funciona.



# Operadores de Identidad [#](#operadores-de-identidad) {#operadores-de-identidad}


Los operadores de identidad se utilizan para comparar objetos. Sin embargo, no comparan si los objetos son iguales, en su lugar, comparan si son el mismo objeto:


|Operador| 	Ejemplo |	Significado|
|--------|----------|------------|
|is 	   | x is y 	| Devuelve `True` si las dos variables son el mismo objeto|
|is not |	x is not y| 	Devuelve `True si las dos variables no son el mismo objeto|


Veamoslo mejor en un caso practico:

tenemos dos variables:

```python
texto1 = "Hola Python"

text2 = "Hola Python"
```
Vemos que ambas variables tienen el mismo valor, pero si aplicamos la funcion reservada `id()`  en cada variable nos da un valor diferente.

```python
id(texto1)

140608469061488

id(texto2)

140608469060976
```

Te preguntaras a que corresponde el valor que nos muestra despues de aplicar la funcion; pues el resultado viene a ser el valor de la porcion de memoria que se le asigna a esa variable en ese preciso momento, ya que si volvemos a crear la misma variable con el mismo valor de nuevo nos mostrara un valor diferente.

```python

texto1 = "Hola Python"

id(texto1)

140608469400944
```
Ahora aplicaremos la comparacion de indentidad a nuestras dos variables previamente creadas:

```python

texto1 is texto2

False

texto1 == texto2

True
```

En el resultado podemos apreciar que `is` nos devuelve `False` a diferencia de cuando aplicamos `==` que nos devuelve `True`:

Esto se debe a que `==` solo nos compara que las variables contengan el mismo valor, pero el `is` nos compara que ambas variables sean el mismo objeto creado en la misma porcion de memoria en otras palabras si tienen el mismo identificador que nos mostraba la funcion `id()`.

Como en el caso siguente que crearemos una nueva variable `texto3` y la igualaremos a la anterior variable que creamos `texto1`, en este caso la variable `texto3` heredara todo de la variable `texto1` esto incluye la porcion de memoria en la que se creo.

Por lo tanto a la hora de ejecutar nuevamente el operador de identidad `is` esta vez nos dara el valor de `True`.

```python
texto3 = texto1

texto3 is texto1

True
```

## Operadores de Pertenencia [#](#operadores-de-pertenencia) {#operadores-de-pertenencia}


Los operadores de pertenencia se utilizan para evaluar sin una secuencia se encuentra presente en un objeto.

|Operador| 	Ejemplo |	Significado|
|--------|----------|------------|
|in 	   | x in y 	| Devuelve `True` si la secuencia x se encuntra presente en y, de lo contrario devuelve `False`|
|not in |	x not in y| 	Devuelve `True` si la secuencia x no se encuentra en y, de lo contrario devuelve `False`|


Veamoslo en un ejemplo:


Obervamos que si la secuencia en este caso `cadena` esta presente en la variable `texto`, esto nos responde `True` ya que solo debe incluirse para que se cumpla esta condicion.

```python
texto = "Mi cadena de texto"

"cadena" in texto

True

"hola" in texto

False

"e" in text

True
```

Pero si intentamos hacer el mismo proceso en un numero entero, recibimos un error ya que el operador `in` solo sirve para secuencias que son iterables

```python
num = 1345678

1 in numero
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-7-882699b1f88c> in <module>
----> 1 1 in numero

TypeError: argument of type 'int' is not iterable
```

## Operadores Logicos [#](#operadores-logicos) {#operadores-logicos}


Los operadores lógicos modifican y unen expresiones evaluadas en contexto booleano para crear condiciones más complejas.

|Operador| 	Ejemplo |	Significado|
|--------|----------|------------|
|not	   | not x 	| Devuelve `True` si x el `False`, de lo contrario devuelve `True`|
|or |	x or y| 	Devuelve `True` si x o y son `True`, de lo contrario devuelve `False`|
| and | x and y | Devuelve `True` si ambos x como y son `True`, de lo contrario devuelve `False` |

### Operador not

Evaluamos la expresion y con `not` invierte el valor que nos devuelve una expresion

```python
numero = 10

numero < 20

True

not numero < 20

False
```

### Operador or


Observamos que el resultado nos devuelve `True`, puesto que si bien la primera condicion es `False`, con el uso del operador `or` solo necesita devolver una de ellas `True`, concretamente ya que la segunda condicion si se cumplia.

```python
numero1 = 10

numero2 = 20

numero1 < 5

False

numero1 < 5 or numero2 > 10

True
```

### Operador and

El operador `and` si requiere que se cumpla la evaluacion de todas las expresiones para que devuelva un valor `True`

```python
numero1 = 5

numero2 = 10

numero1 < 8 and numero2 > 15

False

numero1 < 10 and numero2 > 7

True
```

# Listas [#](#listas) {#listas}



Las listas son un tipo de dato complejo y particular en `Python3`. Una lista se corresponde con una colección arbitraria de objetos. Las listas son similares a estructuras conocidas como arrays en otros lenguajes de programación pero con la diferencia de que en `Python3` aportan mas flexibilidad.

En Python3 se representan con el tipo `list` y la sintaxis que se utiliza para definirlas consiste en indicar una lista de objetos separados entre comas y encerrados entre corchetes: [objeto1, objeto2, ..., objeton]

Veamoslo de manera practica

* Podemos una lista con datos numericos.

```python
lista = [1, 2, 3, 4, 5]

type(lista)

list

print(lista)

[1, 2, 3, 4, 5]
```

* Tambien crear una lista con tipo de datos string

```python
lista2 = ["texto1", "texto2", "texto3"]

type(lista2)

list

print(lista2)

['texto1', 'texto2', 'texto3']
```

Vemos que tenemos una lista igual a la anterior pero con la diferencia que esta contiene cadenas de texto.


* El orden en el que se especifican los elementos cuando se define una lista es relevante y se mantiene durante toda su vida.

```python
lista = ['n1', 'n2', 'n3']

print(lista)

['n1', 'n2', 'n3']
```

* Podemos comparar las listas con los operadores mencionados anteriormente.

```python
lista1 = ['n1', 'n2', 'n3']

lista2 = ['n2', 'n1', 'n3']

lista1 == lista2

False

'n1' in lista2

True

lista1 in lista2

False

lista1 == ['t1', 't2', 't3']

True

lista1 is lista2

False
```

* Las lista pueden contener distintos tipos de datos.


```python
lista = [1, 2, "hola", "python"]

print(lista)

[1, 2, 'hola', 'python']
```

> Una cosa super interesante es que una lista puede contener una `función` estas las veremos mas adelante pero es importante mantenerlo presente

```python
def funcion():
    print("Hola python")

lista = ["texto1", "texto2", funcion]

print(lista)

['texto1', 'texto2', <function funcion at 0x0000012D476D0EE0>]
```

## Acceso a elementos de una lista

Todas las variaciones vistas en la sección de strings (indexing, slicing, stride) aplican a las listas.

### indexing

```python
lista = ["texto1", "texto2", "texto3", "texto4", "texto5"]

lista[0]

'texto1'

lista[-1]

'texto5'
```

### slicing

```python
lista = ["texto1", "texto2", "texto3", "texto4", "texto5"]

lista[2:4]

['texto3', 'texto4']

lista[:3]

['texto1', 'texto2', 'texto3']

lista[2:]

['texto3', 'texto4', 'texto5']
```

### stride

```python
lista = ["texto1", "texto2", "texto3", "texto4", "texto5"]

lista[0:4:2]

['texto1', 'texto3'
```

> otra cosa interesante es que podemos utilizar el concepto de `stride` para darle la vuelta a una `lista`

```python
lista

['texto1', 'texto2', 'texto3', 'texto4', 'texto5']

lista[::-1]

['texto5', 'texto4', 'texto3', 'texto2', 'texto1']
```

> Una de las pocas construcciones sintácticas en cuanto a la `indexación` que cambia entre los `strings` y las `listas` es `[:]`.

* Cuando lo usamos nos devuelve una referencia al propio objeto


```python
texto = "Hola python"

texto[:]

'Hola python'

texto[:] is texto

True
```
* Al utilizarlo con una `lista` nos devuelve una copia del objetivo -> ojo no el mismo.

```python
lista = [1, 2, 3, 4]

lista[:]

[1, 2, 3, 4]

lista[:] is lista

False
```

## Operaciones con listas

Las listas soportan muchos de los operadores y funciones de Python como los que vimos anteriormente.


Al sumar las listas estas se anidan

```python
lista1 = [1, 2, 3]

lista2 = [4, 5, 6]

lista1 + lista2

[1, 2, 3, 4, 5, 6]
```

Cuando usamos el operador de multiplicación, esto hace que se multipliquen sus mismos valores segun el numero por el cual se le multiplique.

```python
lista1 = [1, 2, 3]

lista1 * 2

[1, 2, 3, 1, 2, 3]
```

Tambien podemos ver la longitud, el valor `minimo` y el `maximo` de una lista

```python
lista1 = [1, 2, 3]

lista2 = [4, 5, 6]

len(lista1)

3

min(lista1)

1

max(lista2)

6
```

Solo podemos hacer operaciones entre listas, ya que si tratamos de hacer operaciones con otros tipos en este caso un numero `int` nos arrojara un error.

```python
[1, 2, 3] + 4

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-95-5842ff442cc5> in <module>
----> 1 [1, 2, 3] + 4

TypeError: can only concatenate list (not "int") to list
```

## Listas anidadas

Como mencionamos anteriormente, una lista puede contener cualquier tipo de objeto. Esto incluye otra lista. Una lista puede contener sublistas, que a su vez pueden contener sublistas, y así sucesivamente.

```python
lista = [1, [2, [3, 4], 5], 6]

lista[0]

1

lista[1]

[2, [3, 4], 5]
```

Si queremos acceder a un elemento de una sublista usaremos `[][]`

```python
lista = [1, [2, [3, 4], 5], 6]

lista[1][0]

2

lista[1][1]

[3, 4]

lista[1][1][0]

3
```

> Podemos anidar tantas listas como nuestro sistema soporte


Es importante mencionar que si usamos `operadores` en una `lista` con `sublistas anidadas`, estos solo se aplicaran a la primera, no lo haran de forma recursiva, y se deseariamos usarlos debemos aplicar el concepto de `indexing`


```python
lista = [1, [2, [3, 4], 5], 6]

[3, 4] in lista

False

lista[1]

[2, [3, 4], 5]

[3, 4] in lista[1]

True
```

## Las listas son mutables

Al contrario que los `strings`, los elementos de las `listas`si pueden modificarse

```python
lista = ["texto1", "texto2", "texto3"]

lista[0]

'texto1'

lista[0] = "texto4"

lista

['texto4', 'texto2', 'texto3']
```

Si queremos tambien podemos eliminar elementos una `lista`

```python
lista = ["texto1", "texto2", "texto3"]

del lista[0]

lista

['texto2', 'texto3']
```

Para realizar estas modificaciones tambien podemos usar los conceptos del `indexing`, `slicing` y `stride`.

```python
lista

['texto1', 'texto2']

lista += ["texto3", "texto4", "texto5"]

lista

['texto1', 'texto2', 'texto3', 'texto4', 'texto5']

lista[0:3]

['texto1', 'texto2', 'texto3']

lista[0:3] = [1, 2, 3]

lista

[1, 2, 3, 'texto4', 'texto5']
```

Otra cosa interesante es que el numeros de elementos seleccionados no tiene que ser igual a los que se asigne


```python
lista[0:3]

[1, 2, 3]

lista[0:3] = [1, 2]

lista

[1, 2, 'texto4', 'texto5']

lista[2:2] = [3, 4, 5]

lista

[1, 2, 3, 4, 5, 'texto4', 'texto5']

lista[0:6] = []

lista

['texto5']
```


