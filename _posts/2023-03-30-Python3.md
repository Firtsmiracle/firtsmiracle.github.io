---
layout      : post 
title       : "Aprende Python desde cero a avanzado curso completo"
author      : Firtsmiracle
image       : assets/images/articles/2023-03-30-Python3/py.png
category    : [ articulos ]
tags        : [ Python3, programación ]
---

En esta ocasion hablaremos del lenguaje de programacion `Python3`, realizaremos todo un curso completo desde lo mas basico y explicaremos todo lo escencial para que se pueda llegar a dominar este lenguaje.

> El articulo se ira actualizando constantemente - Ultima actualización `19 - 04 - 2023`

# Que es Python3?

Python3 es un lenguaje de programación ampliamente utilizado en las aplicaciones web, el desarrollo de software, la ciencia de datos y el machine learning. Es preferido entre los desarrolladores porque es eficiente y fácil de aprender, además de que se puede ejecutar en muchas plataformas diferentes, se integra bien a todos los tipos de sistemas y aumenta la velocidad del desarrollo. El software podemos descargarlo gratis de su pagina oficial.


## Indice y Estructura

- [Que es Python3](#que-es-Python3?)
-  [Sintaxis](#sintaxis)
- [Variables](#variables)
    * [Tipos de Variables](#tipos-de-variables) 
    * [Asignación Multiple de Variables](#asignación-multiple-de-variables) 
    * [Sintaxis de Variables](#sintaxis-de-variables)
- [Strings](#strings)
    * [Indexación](#indexación)
    * [Slicing](#slicing)
    * [Stride](#stride)
    * [Modificación de Strings](#modificación-de-strings)
    * [Strings de multiples lineas](#strings-de-multiples-lineas)
- [Numeros](#numeros)
    * [Numeros Enteros](#numeros-enteros)
    * [Numeros Flotantes](#numeros-flotantes)
    * [Numeros Complejos](#numeros-complejos)

- [Comentarios](#comentarios)
    * [Comentarios de Varias Lineas](#comentarios-de-varias-lineas)
- [Operadores Aritmeticos](#operadores-aritmeticos)
    * [Suma y Resta](#suma-y-resta)
        * [Sumar y restar datos Numericos](#sumar-y-restar-datos-numericos)
        * [Sumar y restar datos Strings](#sumar-y-restar-datos-strings)
    * [Multiplicación y División](#multiplicación-y-división)
        * [Multiplicar y dividir datos Numericos](#multiplicar-y-dividir-datos-numericos)
        * [Multiplicar y dividir datos Strings](#multiplicar-y-dividir-datos-strings)
    * [Modulo](#modulo)
    * [Exponencial](#exponencial)
    * [Division Entera](#division-entera)
- [Operadores de Asignación](#operadores-de-asignación)
- [Booleanos](#booleanos)
- [Operadores de Comparación](#operadores-de-comparación)
    *  [Comparación entre datos numericos](#comparación-entre-datos-numericos)
    *  [Comparación entre datos strings](#comparación-entre-datos-strings)
- [Operadores de Identidad](#operadores-de-identidad)
- [Operadores de Pertenencia](#operadores-de-pertenencia)
- [Operadores Logicos](#operadores-logicos)
    * [Operador not](#operador-not)
    * [Operador or](#operador-or)
    * [Operador and](#operador-and)
- [Listas](#listas)
    * [Acceso a elementos de una lista](#acceso-a-elementos-de-una-lista)
    * [Operaciones con listas](#operaciones-con-listas)
    * [Listas anidadas](#listas-anidadas)
    * [Las listas son mutables](#las-listas-son-mutables)
- [Funciones](#funciones)
    * [Funciones Personalizadas](#funciones-personalizadas)
    * [Argumentos de las Funciones](#argumentos-de-las-funciones)
        * [Argumentos Posicionales](#argumentos-posicionales)
        * [Argumentos de Palabras Clave](#argumentos-de-palabras-clave)
        * [Parametros con Valores por Defecto](#parametros-con-valores-por-defecto)
    * [Sentencia Return](#sentencia-return)
    * [Docstrings](#docstring)
    * [Funciones Propias de Python](#funciones-propias-de-python)
- [Tuplas](#tuplas)
    * [Funcionamiento de las Tuplas](#funcionamiento-de-las-tuplas)
    * [Cuando utilizar una Tupla en vez de una Lista](#cuando-utilizar-una-tupla-en-vez-de-una-lista)
    * [Tuplas y tipos de datos Numericos](#tuplas-y-tipos-de-datos-numericos)
    * [Packing y Unpacking - Empaquetado y Desempaquetado](#packing-y-unpacking---empaquetado-y-desempaquetado)
- [Diccionarios](#diccionarios)
    * [Acceso a los elementos de un Diccionario](#acceso-a-los-elementos-de-un-diccionario)


# Sintaxis [#](#sintaxis) {#sintaxis}

Cuando hablamos de la sintaxis en Python3, nos referimos como en todo lenguaje al correcto uso y orden de las palabras que utilizamos para comunicarnos. Por ello, en Python3 también es necesario cumplir ciertos requisitos a la hora de expresarnos.

Comenzaremos con la sintaxis tipica que nos ayuda a imprimir los valores concretamente su nombre es `print` que viene a ser una funcion interna de Python que recibe una variable o tipo de dato y nos lo muestra por pantalla, por ahora solo hay que tener presente el concepto de `print` ya que mas adelante profundizaremos en los demas conceptos que nos ayudaran a comprender mejor como funciona este lenguaje.

```python
print("Hola Python3")

Hola Python3
```

# Variables [#](#variables) {#variables}


Una variable es un elemento de un lenguaje de programación que tiene asignado un valor determinado. Para crear una variable en Python3 debemos proporcionarle un nombre y asignarle un valor utilizando el símbolo `=`.

```python
variable = "Hola Python3"

print(variable)

Hola Python3
```

Ahora el valor asignado a la variable puede cambiar a lo largo del codigo a otra difierente.

```python
variable = "Hola Python3"

print(variable)

Hola Python3

variable2 = "Adios Python3"

print(variable)

Adios Python3
```

## Tipos de Variables

Existen 4 tipos de variables principales o primitivas en Python3, concretamente estas son:

Tipo`int`: Para representar numeros enteros.
Tipo `string`: Para representar texto o cadenas.
Tipo `boolean`: Para representar datos binarios, es decir que pueden tomar los valores `True` o `False`.
Tipo `float`: Para representar numeros con decimales.

| Representacion |Tipo  |
| ------ | -------- | 
|numeros enteros    | int      | 
| cadenas de texo   | string     | 
| numeros decimales   | float |
| dato binario(True o False)   | boolean |


Definimos un conjunto de variables segun su tipo y usamos la funcion reservada de python `type()` para ver el tipo de variable segun su asignacion:

```python
variable1 = 10

variable4 = 2.4

variable2 = "Hola Python"

variable3 = True

variable4 = 2.4

type(variable1)

int

type(variable2)

str

type(variable3)

bool

type(variable4)

float
```

## Asignación Multiple de Variables

En Python3 podemos asignar una variable a otra variable diferente.

```python
variable = "Hola Python3"

variable2 = variable

print(variable2)

Hola Python3
```

## Sintaxis de Variables

En Python3 se debe cumplir con las reglas sintácticas definidas por el leguaje. A continuación indicamos las reglas que debemos cumplir cuando definimos el nombre de una variable:

 * Las variables en Python3 pueden tener cualquier longitud y pueden consistir en letras mayúsculas y minúsculas `A-Z, a-z`, dígitos del `0-9` y el carácter de subrayado o subguion `_`


```python
_variable = "Hola Python3"

print(_variable)

Hola Python3

vAriAbLe = "Hola Python3"

print(vAriAbLe)

Hola Python3

variable_1_1 = "Hola Python3"

print(variable_1_1)

Hola Python3
```

 * Si no se cumple con las reglas definidas de sintaxys, emitiran un error

  ```python
  variable$ = "Hola Python3"

    File "<iPython3-input-12-f520f3dd0eb3>", line 1
      variable$ = "Hola Python3"
         ^
  SyntaxError: invalid syntax
  ```

 * El nombre de una variable puede contener dígitos, pero el primer caracter de un nombre de variable no puede ser un dígito. 
  
  ```python
  1variable = "Hola Python3"

    File "<iPython3-input-13-905ee4ad3fed>", line 1
      1variable = "Hola Python3"
     ^
  SyntaxError: invalid syntax
  ```
   * El nombre de las variables en Python3 es sensible a mayúsculas y minúsculas

   ```python
   Variable1 = "Hola Python3"

   print(variable1)

   ---------------------------------------------------------------------------
   NameError                                 Traceback (most recent call last)
   <iPython3-input-15-32693f267891> in <module>
   ----> 1 print(variable1)

   NameError: name 'variable1' is not defined
   ```

# Strings [#](#Strings) {#Strings}


Un string se corresponde con un conjunto de caracteres que forman una cadena de texto.

La sintaxis que debemos utilizar para definir strings en Python consiste en situar los caracteres entre `" o '`


```python
variable1 = "Esto es mi primer string"

variable2 = 'Esto es mi segunda string'
```

La flexibilidad de definir `string` con el caracter " y el caracter ' nos permite definir cadenas de texto que contienen esos mismos caracteres.

```python
variable1 = 'Los tipos strings pueden definirse con el caracter "'

variable2 = "Los tipos strings pueden definirse con el caracter '"

print(variable1)

Los strings pueden definirse con el caracter "

print(variable2)

Los strings pueden definirse con el caracter '
```

## Indexación

En muchos tipos de datos en Python3 se puede acceder a los elementos individuales de un conjunto de datos directamente mediante un índice numérico o un valor clave. Este proceso se denomina `indexación`.

En Python3, las cadenas son secuencias ordenadas de caracteres, y por lo tanto pueden ser indexadas de esta manera. Se puede acceder a los caracteres individuales de una cadena especificando el nombre de la cadena seguido de un número entre corchetes `[]`.

El primer carácter de la cadena tendra el índice 0, el siguiente el índice 1, y así sucesivamente. El índice del último carácter será la longitud de la cadena menos uno.

```python
lenguaje = "Python"

lenguaje[0]

'P'

lenguaje[2]

't'
```

Podemos tambien utilizar números negativos para extraer los caracteres por el final de la cadena de texto, donde `-1` seria la parte final y asi sucesivamente de derecha a izquierda.

```python
lenguaje[-1]

'n'

lenguaje[-3]

'h'
```

## Slicing

Python3 permite una sintaxis específica de indexación que extrae subcadenas de una cadena de texto, a esto se denomina '`slicing`.

La sintaxis que se utiliza para extraer una subcadena de una cadena de nombre `micadena` es de la forma `micadena[x:y]`, esto devuelve la parte de la cadena `micadena` que comienza en la posición `x`,y termina en la posición `y`; con la exepción de que no se incluye el último caracter.

```python
lenguaje = "Hola Python"

lenguaje[0:4]

'Hola'

lenguaje[-6:-1]

'Pytho'
```
Podemos observar que efectivamente no se incluye el ultimo caracter que se especifica: `ojo tener en cuenta que los espacios tambien son caracteres correspondientes a una cadena vacia` 


Pero que pasaria entonces si no indicamos uno de los numeros:

```python
lenguaje = "Hola Python"

lenguaje[-6:]

'Python'

lenguaje[5:]

'Python'
```

Si no indicamos alguno de los numeros lo que hace Python3 es leer hasta el final.


## Stride

Es una variante más del slicing. Si se añade un : adicional y un tercer índice, se designa una stride, que indica cuantos caracteres saltar hasta obtener el siguiente caracter.

Este salto lo hara contando el propio caracter.

```python
lenguaje = "Hola Python"

lenguaje[0:4:2]

'Hl'

lenguaje[0:4:1]

'Hola'

nombre[0:8:3]

'ha'
```

## Modificación de Strings

Una string es un tipo de dato que en Python3 se considera `inmutable`, esto quiere decir que no podemos modificar una parte de un string asociada a una variable

```python
lenguaje = "Python"

lenguaje[2]

't'

lenguaje[2] = 'a'

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-37-3f77b4874756> in <module>
----> 1 lenguaje[2] = 'a'

TypeError: 'str' object does not support item assignment
```

Pero a pesar de no poderse modificar el contenido de una string, si se puede asignar un string diferente a la variable.

```python
lenguaje = "golang"

print(lenguaje)

golang
```

## Strings de multiples lineas

Si en alguna ocasion queremos definir `strings` de varias lineas podemos hacerlo de varias formas en Python3

Una de ellas seria introducir el caracter `\n` en la posicion de la cadena donde queremos que realize el salto de linea

```python
lenguaje = "Mi\nlenguaje\nfavorito\nes\nPython"

print(lenguaje)
Mi
lenguaje
favorito
es
Python
```

Otra opción tambien podria usar los caracteres `"""`

```python
lenguaje = """Mi
lenguaje
favorito
es
Python
"""

print(lenguaje)
Mi
lenguaje
favorito
es
Python
```

# Numeros

Existen 3 tipos de datos numéricos: enteros `int`, números de punto flotante `float` y números complejos.

## Numeros Enteros

Los números enteros son aquellos que no tienen parte decimal. En Python3 se referencian con la palabra `int`.

```python
num = 10
```
No olvidemos que es muy importante la diferencia de un número entero y una cadena de texto que representa un número entero.

```python
num = 10
num = "10"
```

Podemos convertir una cadena de texto que representa un número entero en un valor numérico utilizando la función `int()`

```python
numero = "10"

print(numero)

'10'

numero2 = int(numero)

print(numero2)

10
```

Para separar algunos dígitos para que sea más facil de leer. No podemos usar el `.` o `,` , para esto Python3 nos da la opcion de usar `_`:

```python
numero = 5000000

print(numero)

5000000

numero2 = 5_000_000

print(numero2)

5000000
```

No hay límite en el tamaño de los números enteros que podemos definir, ya que se pueden definir números enteros tan grandes como la memoria de nuestro sistema soporte.

```python
numero = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

print(numero)

100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

## Numeros Flotantes

Los números flotantes son aquellos que tienen una parte decimal, en `Python3` se referencian con la palabra `float`.

```python
numero = 10.5
```
De igual manera que con los números enteros, se puede convertir una cadena de texto que representa un número flotante a un valor numérico utilizando la función `float()`

```python
numero = "12.4"

print(numero)

'12.4'

numero2 = float(numero)

print(numero2)

12.4
```

Existen tres formas de representarlos en Python3.

```python
numero1 = 1000.0

numero2 = 1_000.0

numero3 = 1e3

print(numero1)

1000.0

print(numero2)

1000.0

print(numero3)

1000.0
```

A diferencia que los números enteros, los número de flotantes si tienen un tamaño máximo en Python3. Aunque el tamaño máximo dependera de nuestro sistema, las cifras cercanas o mayores a `2e400` que equivale a `(2x10)^400` suelen superar el tamaño máximo.

```python
numero = 2e400

print(numero)

inf
```
Python3 devuelve `inf` haciendo referencia a infinito.


## Numeros complejos


Hay pocos lenguajes de programacion que ofrecen soporte integrado para números complejos y Python3 es uno de ellos. Aunque los números complejos no suelen aparecer fuera de los dominios de la computación científica, pueden ser de gran utilidad en dominios que usen técnicas estadísticas.

Un número complejo esta formado por 2 componentes distintos: una parte real y una parte imaginaria. 

En Python3 podemos definir un numero complejo, se define la parte real seguida de un símbolo + y la parte imaginaria terminando con la letra j.

```python
numero = 2 + 4j

print(numero)

(2+4j)

numero.real

2.0

numero.imag

4.0
```

# Comentarios [#](#comentarios) {#comentarios}

Los comentarios son parte fundamental en cualquier lenguaje de programación. Permiten describir partes del código que desarrollamos de manera que sea mucho más facil de comprender. Poner comentarios en nuestro código es una muy buena práctica que debemos realizar.


La manera más simple de poner comentarios en Python3 es utilizando el símbolo `#`

```python
# Este es mi comentario
```

Podemos hacer lo mismo despues de escribir una sentencia en nuestro codigo haciendo referencia al significado de esta:

```python
variable = "Hola Python3" # Esto es una variable
```

## Comentarios de varias lineas

Hay ocasiones en que necesitemos poner comentarios de varias líneas. Python3 no permite crear un comentario de varias líneas utilizando el mismo símbolo #.

```python
# Este comentario
# tiene varias lineas
# para mi ejemplo en Python3
```

Existe una manera mas sencilla y comoda de hacer comentarios en Python3 con el uso de `""" todo el comentario """`.

```python
"""
Este comentario
tiene varias líneas
para mi ejemplo en Python3
"""
```

# Operadores Aritmeticos [#](#operadores-aritmeticos) {#operadores-aritmeticos}


A continuación se muestran los operadores aritméticos soportados por Python3:

| Operador | Significado | 
| ------ | -------- | 
|a + b    | suma      | 
| a - b   | resta     | 
| a * b   | multiplicacion |
|a / b    | division |
| a % b   | modulo |
| a // b  | division de enteros |
| a ** b  | exponencial |


## Suma y Resta

Los operadores suma `+`y resta `-` se pueden aplicar a distintos tipos de datos.

### Sumar y restar datos numericos

Al sumar o restar tipos de datos numericos obtenemos el resultado matematico.

```python
numero1 = 10

numero2 = 8

print(numero1 + numero2)

18

print(numero1 - numero2)

8

print(numero2 - numero1)

-2

numero3 = 2.5

numero4 = 1.5

print(numero3 + numero4)

4.0

print(numero3 - numero4)

1.0
```
    
### Sumar y restar datos strings

Cuando sumamos tipos de datos strings se concatenan las variables.

```python
texto1 = "Hola"

texto2 = "Python"

print(texto1 + texto2)

'HolaPython'
```
Si queremos agregar un espacio, debemos agregar una cadena vacia `" "`, sin embargo no podemos restar dichas cadenas.

```python
print(text1 + " " + text2)

'Hola Python'

print(texto1 - texto2)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-16-ed11b0c86524> in <module>
----> 1 texto1 - texto2

TypeError: unsupported operand type(s) for -: 'str' and 'str'
```

## Multiplicación y División

Los operadores de multiplicacion `*` y division `/` son operadores binarios que pueden aplicarse sobre distintos tipos de datos.

### multiplicar y dividir datos numericos

```python
numero1 = 20

numero2 = 4

numero1 * numero2

80

# IMPORTANTE: El resultado al dividir siempre es un float

print(numero1 / numero2)

5.0
```

### multiplicar y dividir datos strings

No podemos multiplicar o dividir cadenas de texto.

```python
texto1 = "Hola"

texto2 = "Python"

texto1 * texto2

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-21-4d766fa04d9a> in <module>
----> 1 texto1 * texto2

TypeError: can't multiply sequence by non-int of type 'str'

print(texto1 / texto2)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-22-7ba20b66d6c5> in <module>
----> 1 texto1 / texto2

TypeError: unsupported operand type(s) for /: 'str' and 'str'
```

Pero si podemos multiplicar una cadena de texto por un numero entero, que imprime el numero de veces de la cadena segun el que numero por el que multiplicamos.

```python
texto1 * 3

'HolaHolaHola'
```
## Modulo

El operador modulo `%` es un operador binario que devuelve el resto de una división entre tipos de datos numericos ya sean enteros o flotantes.

```python
numero1 = 10

numero2 = 7

print(numero1 % numero2)

3

print(numero2 % numero1)

7

numero1 = 10.5

numero2 = 7.2

print(numero1 % numero2)

3.3
```

## Exponencial

El operador exponencial `**` es un operador binario que se aplica solo en tipos de datos numéricos.

```python
numero1 = 5

numero1 ** 2

25

numero ** 3

125

texto1 = "Hola Python"

texto1 ** 2

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-33-a3cd4ee7680f> in <module>
----> 1 texto1 ** 2

TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
```
## Division Entera

El operador divison entera `//`es un operador binario que se aplica sobre tipos de datos numéricos y devuelve la parte entera del resultado.

```python
numero1 = 10

numero2 = 7

print(numero1 / numero2)

1.4285714285714286

print(numero1 // numero2)

1
```

# Operadores de Asignación [#](#operadores-de-asignación) {#operadores-de-asignación}



Anteriormente ya hemos usado el operador de asignación `=` para asignar un valor a una variable.

Sin embargo Python3 nos proporciona un mecanismo para combinar operadores aritméticos y operadores de asignación simplificando nuestro codigo. Esa combinación se denomina `Augmented Assignment`.


| Operador |           |Significado| 
| ---------|-----------| --------- | 
|a += 4    | es igual a |a = a + 4| 
| a -= 8   | es igual a |a = a - 8 | 
| a *= 10  | es igual a |a = a * 10|
|a /= 5    | es igual a |a = a / 5  |



Veamos unos ejemplos:

```python
numero = 15

numero += 5

print(numero)

20

numero2 = 20

numero2 *= 2

print(numero2)

40

numero3 = 8

numero3 -= 3

print(numero3)

5
```
# Booleanos [#](#booleanos) {#booleanos}


Los tipos de datos Boolenos en Python se representan con el tipo `bool` y reciben únicamente dos posibles valores:

- True
- Fase

```python
variable = True

print(variable)

True
```

Podemos usar la funcion reservada `type` para ver el tipo de variable

```python
variable = True

type(varaible)

bool

variable2 = False

type(variable2)

bool
```

Una cosa a tener en cuenta es que las palabras `True` y `False` son palabras reservadas dentro de Python3 y no se les puede asignar ningún valor.

```python
True = "Hola Python"

  File "<ipython-input-7-31dbcec71c48>", line 1
    True = "Hola Python"
    ^
SyntaxError: cannot assign to True
```

# Operadores de Comparación [#](#operadores-de-comparación) {#operadores-de-comparación}


Son los que evalúan la relación que existe entre dos valores en Python. Existen diferentes tipos:


|Operador| 	Ejemplo| 	Significado|
|--------|--------|------------|
|==|	a == b| 	Igual a|
|!=| 	a != b| 	No igual a|
|<| 	a < b| 	Menor que|
|<= |	a <= b| 	Menor que o igual a|
|> |	a > b| 	Mayor que|
|>= |	a >= b| 	Mayor que o igual a|


### Comparación entre datos numericos

A continacion veremos algunos ejemplos

```python
numero1 = 4

numero2 = 8

numero1 == 4

True

numero1 == numero2

False

numero1 == 4.0

True

numero1 != 4

False

numero1 != numero2

True
```
Otros ejemplos

```python
numero1 = 10

numero2 = 15

numero1 < numero2

True

numero2 < numero1

False

numero1 <= 10.0

True
```

### Comparación entre datos strings

```python
texto1 = "cadena de texto"

texto2 = "cadena de texto 2"

texto1 == "cadena de texto"

True

text1 == text2

False

text1 != text2

True
```

Ahora veamos un tipo de comparación mas inusual

```python
texto1 = "Cadena de mi texto"

texto2 = "texto"

texto1 < texto2

True
```

Podemos ver algo muy extraño 

> Esta comparación utiliza un orden lexicográfico: primero se comparan los dos primeros elementos, y si estos son diferentes, determina el resultado de la comparación; si son iguales, se comparan los dos siguientes elementos, y así sucesivamente, hasta que se agote cualquiera de las dos secuencias.


y ahora se preguntaran si segun el principio tenemos arriba como primer caracter de `texto1 -> C` y de `texto2 -> t` como entonces lo esta haciendo?


Pues esto es por la sencilla razon de que esta comparacion lo realiza utilizando los equivalentes numericos de cada caracter, esto mediante la funcion reservada `ord()`que recibe un caracter y se encarga de transformar un caracter a codigo unicode.


Veamoslo mejor con el ejemplo anterior:

```python
#texto1 = "Cadena de mi texto"
#texto2 = "texto"
#condicion texto1 < texto2

"Cadena de mi texto" < "texto"

True

#Cojemos los primeros caracteres de ambas variables y les aplicamos la funcion ord()

ord('C')

67

ord('t')

116

#tendriamos que C = 67 y t = 116

67 < 116

True
```
Despues de analizar el ejemplo anterior, efectivamente vemos que la condicion era cierta y ahora nos queda claro como es que funciona.



# Operadores de Identidad [#](#operadores-de-identidad) {#operadores-de-identidad}


Los operadores de identidad se utilizan para comparar objetos. Sin embargo, no comparan si los objetos son iguales, en su lugar, comparan si son el mismo objeto:


|Operador| 	Ejemplo |	Significado|
|--------|----------|------------|
|is 	   | x is y 	| Devuelve `True` si las dos variables son el mismo objeto|
|is not |	x is not y| 	Devuelve `True si las dos variables no son el mismo objeto|


Veamoslo mejor en un caso practico:

tenemos dos variables:

```python
texto1 = "Hola Python"

text2 = "Hola Python"
```
Vemos que ambas variables tienen el mismo valor, pero si aplicamos la funcion reservada `id()`  en cada variable nos da un valor diferente.

```python
id(texto1)

140608469061488

id(texto2)

140608469060976
```

Te preguntaras a que corresponde el valor que nos muestra despues de aplicar la funcion; pues el resultado viene a ser el valor de la porcion de memoria que se le asigna a esa variable en ese preciso momento, ya que si volvemos a crear la misma variable con el mismo valor de nuevo nos mostrara un valor diferente.

```python

texto1 = "Hola Python"

id(texto1)

140608469400944
```
Ahora aplicaremos la comparacion de indentidad a nuestras dos variables previamente creadas:

```python

texto1 is texto2

False

texto1 == texto2

True
```

En el resultado podemos apreciar que `is` nos devuelve `False` a diferencia de cuando aplicamos `==` que nos devuelve `True`:

Esto se debe a que `==` solo nos compara que las variables contengan el mismo valor, pero el `is` nos compara que ambas variables sean el mismo objeto creado en la misma porcion de memoria en otras palabras si tienen el mismo identificador que nos mostraba la funcion `id()`.

Como en el caso siguente que crearemos una nueva variable `texto3` y la igualaremos a la anterior variable que creamos `texto1`, en este caso la variable `texto3` heredara todo de la variable `texto1` esto incluye la porcion de memoria en la que se creo.

Por lo tanto a la hora de ejecutar nuevamente el operador de identidad `is` esta vez nos dara el valor de `True`.

```python
texto3 = texto1

texto3 is texto1

True
```

## Operadores de Pertenencia [#](#operadores-de-pertenencia) {#operadores-de-pertenencia}


Los operadores de pertenencia se utilizan para evaluar sin una secuencia se encuentra presente en un objeto.

|Operador| 	Ejemplo |	Significado|
|--------|----------|------------|
|in 	   | x in y 	| Devuelve `True` si la secuencia x se encuntra presente en y, de lo contrario devuelve `False`|
|not in |	x not in y| 	Devuelve `True` si la secuencia x no se encuentra en y, de lo contrario devuelve `False`|


Veamoslo en un ejemplo:


Obervamos que si la secuencia en este caso `cadena` esta presente en la variable `texto`, esto nos responde `True` ya que solo debe incluirse para que se cumpla esta condicion.

```python
texto = "Mi cadena de texto"

"cadena" in texto

True

"hola" in texto

False

"e" in text

True
```

Pero si intentamos hacer el mismo proceso en un numero entero, recibimos un error ya que el operador `in` solo sirve para secuencias que son iterables

```python
num = 1345678

1 in numero
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-7-882699b1f88c> in <module>
----> 1 1 in numero

TypeError: argument of type 'int' is not iterable
```

## Operadores Logicos [#](#operadores-logicos) {#operadores-logicos}


Los operadores lógicos modifican y unen expresiones evaluadas en contexto booleano para crear condiciones más complejas.

|Operador| 	Ejemplo |	Significado|
|--------|----------|------------|
|not	   | not x 	| Devuelve `True` si x el `False`, de lo contrario devuelve `True`|
|or |	x or y| 	Devuelve `True` si x o y son `True`, de lo contrario devuelve `False`|
| and | x and y | Devuelve `True` si ambos x como y son `True`, de lo contrario devuelve `False` |

### Operador not

Evaluamos la expresion y con `not` invierte el valor que nos devuelve una expresion

```python
numero = 10

numero < 20

True

not numero < 20

False
```

### Operador or

Observamos que el resultado nos devuelve `True`, puesto que si bien la primera condicion es `False`, con el uso del operador `or` solo necesita devolver una de ellas `True`, concretamente ya que la segunda condicion si se cumplia.

```python
numero1 = 10

numero2 = 20

numero1 < 5

False

numero1 < 5 or numero2 > 10

True
```

### Operador and

El operador `and` si requiere que se cumpla la evaluacion de todas las expresiones para que devuelva un valor `True`

```python
numero1 = 5

numero2 = 10

numero1 < 8 and numero2 > 15

False

numero1 < 10 and numero2 > 7

True
```

# Listas [#](#listas) {#listas}

Las listas son un tipo de dato complejo y particular en `Python3`. Una lista se corresponde con una colección arbitraria de objetos. Las listas son similares a estructuras conocidas como arrays en otros lenguajes de programación pero con la diferencia de que en `Python3` aportan mas flexibilidad.

En Python3 se representan con el tipo `list` y la sintaxis que se utiliza para definirlas consiste en indicar una lista de objetos separados entre comas y encerrados entre corchetes: [objeto1, objeto2, ..., objeton]

Veamoslo de manera practica

* Podemos una lista con datos numericos.

```python
lista = [1, 2, 3, 4, 5]

type(lista)

list

print(lista)

[1, 2, 3, 4, 5]
```

* Tambien crear una lista con tipo de datos string

```python
lista2 = ["texto1", "texto2", "texto3"]

type(lista2)

list

print(lista2)

['texto1', 'texto2', 'texto3']
```

Vemos que tenemos una lista igual a la anterior pero con la diferencia que esta contiene cadenas de texto.


* El orden en el que se especifican los elementos cuando se define una lista es relevante y se mantiene durante toda su vida.

```python
lista = ['n1', 'n2', 'n3']

print(lista)

['n1', 'n2', 'n3']
```

* Podemos comparar las listas con los operadores mencionados anteriormente.

```python
lista1 = ['n1', 'n2', 'n3']

lista2 = ['n2', 'n1', 'n3']

lista1 == lista2

False

'n1' in lista2

True

lista1 in lista2

False

lista1 == ['t1', 't2', 't3']

True

lista1 is lista2

False
```

* Las lista pueden contener distintos tipos de datos.


```python
lista = [1, 2, "hola", "python"]

print(lista)

[1, 2, 'hola', 'python']
```

> Una cosa super interesante es que una lista puede contener una `función` estas las veremos mas adelante pero es importante mantenerlo presente

```python
def funcion():
    print("Hola python")

lista = ["texto1", "texto2", funcion]

print(lista)

['texto1', 'texto2', <function funcion at 0x0000012D476D0EE0>]
```

## Acceso a elementos de una lista

Todas las variaciones vistas en la sección de strings (indexing, slicing, stride) aplican a las listas.

### indexing

```python
lista = ["texto1", "texto2", "texto3", "texto4", "texto5"]

lista[0]

'texto1'

lista[-1]

'texto5'
```

### slicing

```python
lista = ["texto1", "texto2", "texto3", "texto4", "texto5"]

lista[2:4]

['texto3', 'texto4']

lista[:3]

['texto1', 'texto2', 'texto3']

lista[2:]

['texto3', 'texto4', 'texto5']
```

### stride

```python
lista = ["texto1", "texto2", "texto3", "texto4", "texto5"]

lista[0:4:2]

['texto1', 'texto3'
```

> otra cosa interesante es que podemos utilizar el concepto de `stride` para darle la vuelta a una `lista`

```python
lista

['texto1', 'texto2', 'texto3', 'texto4', 'texto5']

lista[::-1]

['texto5', 'texto4', 'texto3', 'texto2', 'texto1']
```

> Una de las pocas construcciones sintácticas en cuanto a la `indexación` que cambia entre los `strings` y las `listas` es `[:]`.

* Cuando lo usamos nos devuelve una referencia al propio objeto


```python
texto = "Hola python"

texto[:]

'Hola python'

texto[:] is texto

True
```
* Al utilizarlo con una `lista` nos devuelve una copia del objetivo -> ojo no el mismo.

```python
lista = [1, 2, 3, 4]

lista[:]

[1, 2, 3, 4]

lista[:] is lista

False
```

## Operaciones con listas

Las listas soportan muchos de los operadores y funciones de Python como los que vimos anteriormente.


Al sumar las listas estas se anidan

```python
lista1 = [1, 2, 3]

lista2 = [4, 5, 6]

lista1 + lista2

[1, 2, 3, 4, 5, 6]
```

Cuando usamos el operador de multiplicación, esto hace que se multipliquen sus mismos valores segun el numero por el cual se le multiplique.

```python
lista1 = [1, 2, 3]

lista1 * 2

[1, 2, 3, 1, 2, 3]
```

Tambien podemos ver la longitud, el valor `minimo` y el `maximo` de una lista

```python
lista1 = [1, 2, 3]

lista2 = [4, 5, 6]

len(lista1)

3

min(lista1)

1

max(lista2)

6
```

Solo podemos hacer operaciones entre listas, ya que si tratamos de hacer operaciones con otros tipos en este caso un numero `int` nos arrojara un error.

```python
[1, 2, 3] + 4

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-95-5842ff442cc5> in <module>
----> 1 [1, 2, 3] + 4

TypeError: can only concatenate list (not "int") to list
```

## Listas anidadas

Como mencionamos anteriormente, una lista puede contener cualquier tipo de objeto. Esto incluye otra lista. Una lista puede contener sublistas, que a su vez pueden contener sublistas, y así sucesivamente.

```python
lista = [1, [2, [3, 4], 5], 6]

lista[0]

1

lista[1]

[2, [3, 4], 5]
```

Si queremos acceder a un elemento de una sublista usaremos `[][]`

```python
lista = [1, [2, [3, 4], 5], 6]

lista[1][0]

2

lista[1][1]

[3, 4]

lista[1][1][0]

3
```

> Podemos anidar tantas listas como nuestro sistema soporte


Es importante mencionar que si usamos `operadores` en una `lista` con `sublistas anidadas`, estos solo se aplicaran a la primera, no lo haran de forma recursiva, y se deseariamos usarlos debemos aplicar el concepto de `indexing`


```python
lista = [1, [2, [3, 4], 5], 6]

[3, 4] in lista

False

lista[1]

[2, [3, 4], 5]

[3, 4] in lista[1]

True
```

## Las listas son mutables

Al contrario que los `strings`, los elementos de las `listas`si pueden modificarse

```python
lista = ["texto1", "texto2", "texto3"]

lista[0]

'texto1'

lista[0] = "texto4"

lista

['texto4', 'texto2', 'texto3']
```

Si queremos tambien podemos eliminar elementos una `lista`

```python
lista = ["texto1", "texto2", "texto3"]

del lista[0]

lista

['texto2', 'texto3']
```

Para realizar estas modificaciones tambien podemos usar los conceptos del `indexing`, `slicing` y `stride`.

```python
lista

['texto1', 'texto2']

lista += ["texto3", "texto4", "texto5"]

lista

['texto1', 'texto2', 'texto3', 'texto4', 'texto5']

lista[0:3]

['texto1', 'texto2', 'texto3']

lista[0:3] = [1, 2, 3]

lista

[1, 2, 3, 'texto4', 'texto5']
```

Otra cosa interesante es que el numeros de elementos seleccionados no tiene que ser igual a los que se asigne


```python
lista[0:3]

[1, 2, 3]

lista[0:3] = [1, 2]

lista

[1, 2, 'texto4', 'texto5']

lista[2:2] = [3, 4, 5]

lista

[1, 2, 3, 4, 5, 'texto4', 'texto5']

lista[0:6] = []

lista

['texto5']
```

# Funciones [#](#funciones) {#funciones}

Antes de continuar con el contenido del curso se me hace necesario tocar ya el tema de funciones. Hemos visto distintos tipos de datos anteriormente, pero ahora vamos a profundizar en una de las estructuras principales de `python` que son las `funciones`.

Una función va a consistir en un bloque de código que va encapsular una tarea específica o un grupo de tareas relacionadas. Las funciones nos permiten dividir programas complejos en fragmentos más pequeños y modulares, de manera que podamos volver a utilizar estos fragmentos de codigo en un momento determinado de modo tal que no tenemos que volver a implementarlo.


En este caso vamos a invocar una función que ya viene definida en `python`. Concretamente una que ya vimos antes de nombre `len`.


Vamos a comenzar declarando una variable y lo siguiente sera ver como podemos invocar una función.

```python
variable = "Hola Python"
```
Para invocar la función debemos de poner el nombre de la función y entre parentesis ponemos los argumentos de la función. Esta función lo que hara es ejecutar una serie de lineas de codigo que estan definidas en alguna parte de `python` y nos devuelve el numero de caracteres que contiene nuestra variable.

```python
len(variable)

11
```

Ahora el resultado que nos devuelve la función, podemos asignarlo a otra variable.

```python
len_variable = len(variable)

print(len_variable)

11
```

La función que se muestra anterioremente forma parte de un conjunto de funciones que estan definidas en el interprete de `Python` y podemos utilizar siempre que lo necesitemos.


Para utilizar estas funciones no necesitamos conocer el detalle del código fuente que la implementa, únicamente necesitamos conocer:

* Los argumentos recibe la función
* Los valores que devuelve

Mas adelante veremos a detalle las funciones integradas de `python`.


## Funciones Personalizadas [#](#funciones-personalizadas) {#funciones-personalizadas}

Para poder definir funciones en `python` la sintaxis utilizada es la siguiente:

```python
def <nombre_funcion>([<parámetros>]):
    <sentencia(s)>
```

Debemos comenzar utilizando la palabra clave `def` despues de un espacio ponemos el `nombre_función` que queremos definir y entre `()` los parametros que va a recibir nuestra función, la cual se va a traducir a los elementos que le vamos a proporcionar cuando la llamemos.

El elemento, `<sentencia(s)>`, se denomina cuerpo de la función. El cuerpo es el bloque de sentencias en `Python` que se ejecutará cuando se llame a la función. Cabe mencionar que el cuerpo de una función de Python se define por la sangría.


Vamos a comenzar definiendo nuestra función:

```bash
def mi_funcion(argumento1, argumento2):
    print(argumento1)
    print(argumento2)
```

Como podemos visualizar he definico una función de nombre `mi_funcion` que va a recibir 2 parametros `argumento1 y argumento2` y el codigo que ejecutara sera con `print` imprimirme por pantalla primero el `argumento1` y segundo el `argumento2`


Ahora para ejecutarla la función es super sencillo. La sintaxis debe ser la siguiente: `<nombre_funcion>([<argumentos>])`. 

> Cabe resaltar que Los `<argumentos>` son los valores que se pasan a la función. Se corresponden con los `<parámetros>` en la definición de la función que asignamos.

Por lo tanto para llamar a la función, deberiamos hacerlo de la siguente manera:

```bash
mi_funcion("Hola Python", "Adios Python")

Hola Python
Adios Python
```

Es importante mencionar que la ejecución de nuestro programa sera secuencial hasta que llegue a la `función`.

Para entendero mejor, supongamos que estoy defiendo un programa:

1.- Primero, ejecutar un print("Curso Python")
2.- Segundo, llamare a mi función antes declarada, no sin olvidar añadir los parametros que necesita
3.- Tercero, volvere a ejecutar un print("Aprende Python")

```python
print("Curso Python")
mi_funcion("Hola Python", "Adios Python")
print("Aprendere Python")
```

Como resultado tendre que el interprete de `python` comenzara a ejecutar mi programa linea por linea.

```python
Curso Python
Hola Python
Adios Python
Aprendere Python
```

> Lo que quiero resaltar es que necesitamos crear funciones relacionadas con tareas especificas que realizen una acción particular, de tal modo que podamos volver a reutilizar.


Bueno por si habia duda tambien se pueden definir funciones que no reciban ningún argumento, pero los paréntesis siempre seran necesarios. Tanto en una definición de función como una llamada a una función deben incluir siempre paréntesis, incluso si están vacíos.

```python
def mi_funcion2():

    print("Hola Python")
    print("Adios Python")
```

De tal modo que para ahora llamar a mi función solo debo de poner el nombre de las función y los `()`.

```python
mi_funcion2()

Hola Python
Adios Python
```

## Argumentos de las Funciones [#](#argumentos-de-las-funciones) {#argumentos-de-las-funciones}


Los argumentos que podemos proporcionarle a una función en Python pueden ser de diferentes tipos.

### Argumentos Posicionales

Como vimos anteriormente la forma más sencilla de pasar argumentos a una función en `Python` es con argumentos posicionales (llamados tambien argumentos requeridos). En la definición de la función, debe especificarse una lista de parámetros separada por comas dentro de los paréntesis.

```python
def mi_funcion(argumento1, argumento2, argumento3):
    print(argumento1)
    print(argumento2)
    print(argumento3)
```

Los argumentos que le proporcionamos en la invocación de la función debe respetar el orden y el número de parámetros definidos.

```python
mi_funcion("Hola Python", "Adios Python", "Grande Python")

Hola Python
Adios Python
Grande Python
```
Si yo trato de llamar a la función, pero en lugar de pasarle los tres argumentos solo le paso dos.


```python
mi_funcion("Hola Python", "Adios Python")

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-12-c560729c0eac> in <module>
----> 1 mi_funcion("Hola Python", "Adios Python")

TypeError: mi_funcion() missing 1 required positional argument: 'argumento3'
```

Como vemos lo que ocurre es que el interprete de `python` me dara un error, donde me dira que a la `función` que defini previamente con tres argumentos me ha faltado ponerle un elemento posicional correspondiente a `argumento3`. Ya que ha identificado un valor para `argumento1 y argumento2`, pero no para `argumento3`. Y como es un argumento posicional es obligatorio que ponga el mismo numero de argumentos como parametros definamos en nuestra `función`.

> Los parámetros se comportan como variables que estan definidas de manera local a la función (únicamente en el cuerpo de la función). Cuando se invoca la función, los argumentos que se le proporcionan se asignan a los parámetros en el orden en el que estuvieran definidos. Esto quiere decir que los parametros que yo estoy poniendo en la definición de la función se van a comportar como variables dentro del cuerpo de la función, pero no fuera del cuerpo.


Vamos a ver un ejemplo para entender esto mejor:

Primero voy a definir una función que no recibira ningun argumento, lo que hara sera simplemente crear una variable `var` que le asignara una cadena de texto y me lo imprimira por pantalla.

```python
def mi_funcion():
    var = "mi variable 'var' dentro de la funcion"
    print(var)
```

Ahora voy a definir otra variable con el mismo nombre `var` fuera de la función y le voy a asignar una cadena de texto. Seguidamente llamara a mi función previamente creada y finalmente imprimire por pantalla la variable `var`.


```python
var = "variable 'var' fuera de mi función"
mi_funcion
print(var)
```

Ahora al ejecutar esto lo que me muestra es:

```python
variable 'var' dentro de la funcion
variable 'var' fuera de la funcion
```

Como podemos ver lo primero que me imprime el programa es `variable 'var' dentro de la funcion` y despues `variable 'var' fuera de la funcion`.

Esto ocurre por que tanto los parametros y variables que definamos dentro de una `función` van a estar en el contexto local de esa `función` y no va a afectar a lo que hayamos definido fuera. Por ello aunque yo haya definido una variable con el mismo nombre, para `python` son variables diferentes ya que se encuentran en contextos diferentes, una dentro de la función y otra fuera de esta.


### Argumentos de Palabras Clave

Otra manera de invocar una función en `Python` es indicando los argumentos de la forma `<palabra clave>=<valor>`. En ese caso, cada `<palabra clave>` debe coincidir con un parámetro en la definición de la función.

Veamoslo mejor en un ejemplo para entenderlo bien:

Comencemos definiendo una función

```python
def mi_funcion(argumento1, argumento2):
    print(argumento1)
    print(argumento2)
```

Lo siguiente que hare sera invocar la `función` pero en este caso le pasare argumentos de palabra clave en lugar de posicionales.

Voy a definir dos variables 

```python
variable1 = "Hola Python"
variable2 = "Adios Python"
```

Ahora llamare a mi `función`, pero en lugar de pasarle las variables como argumentos posicionales, que seria algo como `mi_funcion(variable1, variable2)`. Lo que hare sera indicarle el nombre del parametro que quiero que este asociado con el argumento que le pase.


```python
mi_funcion(argumento1=variable1, argumento2=variable2)

Hola Python
Adios Python
```
Si quisiera podria invertirlo y el resultado me lo sacaria alreves.

```python
mi_funcion(argumento1=variable2, argumento2=variable1)

Adios Python
Hola Python
```

> Una cosa que es importante sobre los `argumentos de palabras clave` es que no tenemos que respetar el orden de los parametros para pasarle los argumentos.


Aunque en la definición de nuestra `función` pusimos como primer parametro `argumento1` y segundo `argumento2`. Como yo le digo a que valor estan asignados, puedo cambiar el orden y no necesitamos que esten en el mismo orden que en la definición.

```python
mi_funcion(argumento2=variable1, argumento1=variable2)

Adios Python
Hola Python
```

Otra cosa que debemos tener en cuenta es que no podemos poner el nombre de un argumento que no se encuentre definido como parametro de la `función`

```python
mi_funcion(argumento1=variable1, argumento3=variable2)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-17-96e6349729cf> in <module>
----> 1 mi_funcion(argumento1=variable1, argumento3=variable2)

TypeError: mi_funcion() got an unexpected keyword argument 'argumento3'
```

Logicamente `python` me dara un error ya que el `argumento3` no se encuentra en la definición de nuestra `función`.


De la misma manera tenemos que respetar el numero de argumentos que le pasamos al invocar nuestra `función`. De otra manera este nos dara un error de que falta un argumento posicional.

```python
mi_funcion(argumento1=variable1)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-20-c46543542516> in <module>
----> 1 mi_funcion(argumento1=variable1)

TypeError: mi_funcion() missing 1 required positional argument: 'argumento2'
```

> Otra de las cosas interesantes que nos permite hacer `Python`, es la combinación argumentos posicionales y de palabra clave en la misma llamada a una función. En estos casos, siempre los argumentos posicionales deben indicarse primero.


```python
def mi_funcion(argumento1, argumento2):
    print(argumento1)
    print(argumento2)

variable1 = "Hola Python"
variable2 = "Adios Python"


mi_funcion(variable1, argumento2=variable2)

Hola Python
Adios Python
```

Como podemos ver que efectivamente el programa se nos ejecuta correctamente.


Pero ahora que pasa si yo pongo el segundo parametro comi posicional.

```python
mi_funcion(argumento1 = variable1, variable2)
    mi_funcion(arg1=var, var2)
                             ^
SyntaxError: positional argument follows keyword argument
```
Pues esto me dara un error que me dira que hay un argumento posicional que sigue a un argumento de palabra clave. Entonces necesariamente tiene que ser alreves.

### Parametros con Valores por defecto

Si especificamos un parámetro en la definición de una función en `Python` utilizando la forma `<nombre>=<valor>`, entonces `<valor>` se convierte en un valor por defecto para ese parámetro. A eso denominamos parametros por defecto.

Vamos a definir una función, donde le pasaremos dos parametros y que el segundo correspondera a uno por defecto.

```python
def mi_funcion(argumento1, argumento2="Valor por defecto"):
    print(argumento1)
    print(argumento2)
```

Lo que me permite es jugar con el numero de argumentos que le paso a la función, ya que esta vez puedo pasarle menos argumentos de los que estan definidos al invocar a la `función`

```python
mi_funcion("Hola Python")

Hola Python
Valor por defecto
```

Lo que hace la función es decir que el primer argumento necesita si o si que me pase un valor, entonces como ya se lo pasamos, esto lo asignara a `argumento1` y nos los sacara por pantalla este primer argumento. Ahora en lo que corresponde al segundo parametro si le pasamos algo lo asignara a `argumento2`, de lo contrario cogera el valor que tiene por defecto y como en este caso no le pasamos nada lo que hizo fue imprimirnos el valor por defecto.


Pero si ahora yo le indico un valor. Como esta vez le estamos asignando un valor al `argumento2`, esta vez no necesitara el valor por defecto y por lo tanto lo descarta y imprimira el valor que le hayamos pasado.


```python
mi_funcion("Hola Python", "Adios Python")

Hola Python
Adios Python
```


## Sentencia Return 

Las funciones en `Python` pueden retornar un valor despues de haber ejecutado las sentencias de código definidas. Para devolver un valor, se debe utilizar la palabra `return` dentro del cuerpo de la función.

Ahora hay que tener en cuenta algunas cosas cuando utilizamos `return`:

* Cuando se ejecuta `return` en `Python`, el intérprete termina inmediatamente la ejecución de la función y regresa a la línea de código desde dónde la hubiésemos invocado.

Vamos a verlo en un ejemplo mas practico.

Comenzamos definiendo una función simple donde ejecutaremos un `print` de un texto, despues usaremos la sentencia `return` y finalmente volveremos a ejecutar otro `print`.

```python
def mi_funcion():
    print("Sentencia 1 dentro de mi funcion")
    return
    print("Sentencia 2 dentro de mi funcion")
```

Ahora escribiremos codigo fuera de nuestra función, donde primero haremos un `print`, despues llamaremos a la `función` que creamos y finalmente usaremos otro `print`. 

```python
print("Sentencia 1 fuera de mi funcion")
mi_funcion()
print("Sentencia 2 fuera de mi funcion")
```

Al ejecutar esto lo que pasara es que se ejecutara la primera linea, despues ejecutara nuestra `función`, la cual tiene tres lineas donde se ejecutara la primera linea con normalidad, pero después en la segunda linea al estar la sentencia `return`, terminara la ejecución de nuestra `función` sin ejecutar la tercera linea y retornara la ejecución a donde se ejecuto la `función` y en consecuencia se ejecutara el `print` de la ultima linea.


```python
Sentencia 1 fuera de mi funcion
Sentencia 1 dentro de mi funcion
Sentencia 2 fuera de mi funcion
```

* Si definimos la palabra `return` de la forma `return <valor>` se retornará el `<valor>` especificado en la llamada a dicha función.


```python
def mi_funcion():
    return "Valor de la funcion"
    print("Esta linea nunca podra ejecutarse")
```

Esto nos permite que al invocar nuestra `función` podamos recibirla en una variable. Y lo que hara la `función` sera ejecutarme el `return` y devolverme el resultado en la variable `mi_variable`, que en consecuencia al imprimirla me deolvera la cadena de texto que esta asociada al `return`.

Cabe mencionar que el `print` de la `función` no se ejecutara debido a que debemos recordar que el `return` termina la ejecución de la `función`

```python
mi_variable = mi_funcion()

print(mi_variable)

Valor de la funcion
```

Tambien podria ejecutar mi `función` sin asignarsela a ninguna variable.

```python
mi_funcion()

Valor de la funcion
```

Ojito una cosa muy interesante tambien es que podria aplicar a esta `función`. Ya que nos devuelve una cadena de texto, podria aplicar conceptos como el de `slide`, `slicing` y `stride`

```python
mi_funcion()[0:5]

Valor
```

* Si no indicamos el término `<valor>` en la sentencia `return` se devuelve un tipo de datos conocido como `None`

```python
def mi_funcion():
    return

variable = mi_funcion()

print(variable)

None
```

* Podemos utilizar la sentencia `return` para devolver varios valores utilizando la sintaxis `return <valor1>,<valor2>,...,<valorn>`

Supongamos que definimos una `función` que queremos que retorne tres cadenas de texto.

```python
def mi_funcion():
    return "texto1","texto2","texto3"
```

Y cogeria estos valores, definiendo tres variables e igualandolas a la `función`

```python
variable1,variable2,variable3 = mi_funcion()
```

Si ahora imprimo las variables

```python
print(var1)

print(var2)

print(var3)

texto1
texto2
texto3
```

## Docstrings

Los `docstring` los utilizamos para proporcionar la documentación de una `función`. Como el propósito de la función, los argumentos que va a tomar, información sobre los valores de retorno, o cualquier otra información que consideremos útil.

Cuando la primera declaración en el cuerpo de una `función` en `Python` es un string de la forma `"""texto"""`, esto es lo que se conoce como `docstring`.

Aqui tenemos un ejemplo de como lo podemos definir:

```python
def mi_funcion():
    """Esto es un docstring de nuestra función"""
    print("Hola Python")
```

Tambien podemos definir `docstring` de varias lineas.

```python
def mi_funcion2(argumento1=4, argumento2=8):
    """Este es un docstring de varias líneas.

    Argumentos:
    argumento1 -- primer argumento de la funcion (valor por defecto 4)
    argumento2 -- segundo argumento de la funcion (valor por defecto 8)
    """
    return
```

## Funciones Propias de Python

El intérprete de `Python` tiene una serie de funciones que están siempre disponibles. A continuación se enumeran en orden alfabético.


| | |**Lista de Funciones**| | |
|:--------:|:----------:|:------------:|:----------:|:---------:|
|**abs()**|  **delattr()**| **hash()**| **memoryview()**  | **set()**  |
|**all()**| **dict()** |**help()**| **min()**  | **setattr()**  |
|**any()**|**dir()**| **hex()**| **next()**  | **slice()**  |
|**ascii()**|**divmod()**| **id()**| **object()**  | **sorted()**  |
|**bin()**|**enumerate()**| **input()**| **oct()**  | **staticmethod()**  |
|**bool()**| **eval()**| **int()**|**open()**  | **str()**|
|**breakpoint()**|**exec()**| **isinstance()**| **ord()**  | **sum()** |
|**bytearray()**|**filter()**| **issubclass()**| **pow()**  | **super()** |
|**bytes()**|**float()**| **iter()**| **print()**  | **tuple()**|
|**callable()**|**format()**| **len()**| **property()**  | **type()**  |
|**chr()**|**frozenset()**| **list()**| **range()**  | **vars()** |
|**classmethod()**|**getattr()**| **locals()**| **repr()**  | **(zip)** |
|**compile()**|**globals()**| **map()**| **reversed()**  | **__import__()** |
|**complex()**|**hasattr()**| **max()**| **round()**  |   |


Estas son todas las funciones disponibles que estan integradas en `python`. A continuación veremos algunas de las mas importantes, pero no esta de mas practicar para ver de que trata cada una de ellas.


Comenzaremos con la función `help` que se utiliza para mostrar la documentación de un `objeto`. Si la invocamos sin asignarle ningun objeto y me saldra una sesión interactiva donde podemos introducir algo sobre lo que queremos saber su información, en este caso introduciremos `len`.


```python
help()

Welcome to Python 3.10's help utility!

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at https://docs.python.org/3.9/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, symbols, or topics, type
"modules", "keywords", "symbols", or "topics".  Each module also comes
with a one-line summary of what it does; to list the modules whose name
or summary contain a given string such as "spam", type "modules spam".

help> len
Help on built-in function len in module builtins:

len(obj, /)
    Return the number of items in a container.
```

Como vemos despues de introducir la función `len` nos dice que es una función que nos retorna el numero de elementos que tiene un objeto que le proporcione como elemento.


Continuando con otras funciones vamos a utilizar `help` ahora con `print`

```python
help(print)

Help on built-in function print in module builtins:

print(...)
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
    
    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
```

Probemos entonces. Aqui estariamos utilizando los valores por defecto.

```python
print("Hola Python")

Hola mundo
```

Ahora tambien podemos pasarle dos valores, pueden ser de cualquier valor.

```python
print("Soy el numero", 1)

Soy el numero 1
```

Probemos ahora la opción `sep` que nos muestro al usar `help`. Lo que hara sera separarnos los valores por lo que introduzcamos en `sep`

```python
print("Soy el numero", 1, sep=":")

Soy el numero:1
```

Continuemos con otras funciones importantes que ya habiamos visto un poco antes. Concretamente seria `int, str y float`

Vamos a definir primero una serie de variables.

```python
texto = "10" # esta variable es una string
numero_int = 10 # esta variable corresponde a un int
numero_float = 10.6 # esta variable es un float
```

Seguidamente vamos a probar estas funciones:

Si usamos `int` en la variable de texto esta nos la devolvera como entero.

```python
int(texto)

10
```

Y si ahora usamos la función `str` sobre el entero, pues nos devolvera la variable transformada a string.

```python
str(numero_int)

'10'
```

Aplicando lo mismo con un `float` nos devolveria el resultado en flotante.

```python
float(numero_int)

10.0
```

Otra de las funciones importantes es `type` que lo que hace es retornar el tipo del objeto que le proporcionamos como argumento.

Veamosla a continuación:

```python
type(10)

int

type("10")

str

type(10.5)

float
```

Podriamos hacerlo para cualquier tipo de dato.

```python
lista = [1, 2, 3, 4]

type(lista)

list
```

Tenemos tambien a la función `id` que la vimos anteriormente. Y como mencioamos al pasarle un objeto nos dara como valor un numero asociado a la porción de memoria que este ocupa en la memoria.


```python
texto = "Hola Python"

id(texto)

139906352396400
```

Veamos ahora la función `exec`, que ejecuta el codigo que le pasemos como argumento en formato string.

Definimos una variable que contiene una sentencia `print`. Que si la ejecutamos con `exec` nos va a relizar la ejecución de lo que contenia nuestra variable.

```python
variable = "print('Hola Python')"

exec(variable)

Hola Python
```

Tambien podemos tener funciones como `round` que sirve para redondear un valor, `max y min` para obtener el valor maximo y minimo y `range` para obtener un rango de numeros asociados.


Lo recomendable es hechar un ojo a cada una de ellas para saber en que consiste cada una, pero cabe mencionar que la mayoria de ellas las veremos a lo largo del curso.


# Tuplas [#](#tuplas) {#tuplas}

Una tupla viene a ser un objeto identico a una lista excepto por dos propiedades:

* Definen una colección ordenada de objetos, sin embargo utilizan `()` en la sintaxis (objeto1, objeto2, ..., objetojn)

* A diferencia que las lista, las tuplas son tipos de datos inmutables


La representación dentro de `python` con el tipo de dato `tuple`

Veamoslo a continuación

```python
tupla = (1, 2, 3, 4, 5)

type(tupla)

tuple
```

Se pueden aplicar todas las funciones que aplicabamos a las listas.

```python
print(tupla)

(1, 2, 3, 4, 5)

len(tupla)

5
```

## Funcionamiento de las Tuplas

Podemos mezclar todo tipo de datos en una tupla, al igual que podemos usar conceptos como `slide`, `stride` y `slicing`

```python
tupla = (1, 2, 3, "texto1", "texto2", "texto3")

print(tupla)

(1, 2, 3, 'text1', 'text2', 'text3')

tupla[0:4]

(1, 2, 3, text1)
```

Como mencionaba antes y hay que tenerlo muy presente es que las tuplas no pueden modificarse, ya que son inmutables y si tratamos de hacerlo `python` nos dara un error.


```python
tupla = (1, 2, 3, "texto1", "texto2", "texto3")

tupla[2] = "texto0"

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-7-6b0bedb66139> in <module>
----> 1 tupla[2] = "texto0"

TypeError: 'tuple' object does not support item assignment
```

Ahora seguro te preguntaras, si ya tenemos listas que son un objeto super potente en `python` y a diferencia de las  `tuplas`, estas si podemos modificarlas. Entonces ¿Por que usaria una tupla?

Pues esto lo veremos a continuación.


## Cuando utilizar una tupla en vez de una lista

Existen algunos casos donde es mas recomendable usar tuplas en lugar de lista.

* Cuando se manipula una `tupla`, la ejecución del programa es mucho mas rapida. Esto cuando utilizamos una `lista` o `tupla` con muchos elementos.

* El uso de una `tupla` protege contra una modificación accidental

* Existe un tipo de dato llamado `diccionario` que lo veremos un poco mas adelante, que requiere como uno de sus componentes un valor inmutable. Por ello una `tupla` puede utilizarse para este proposito mientras que una `lista` no.

* Podemos usar el `empaquetado` y `desempaquetado` que lo veremos un poquito mas adelante


Para cualquier otro caso de uso que no sean los que hago mención, es mucho mas recomendable el uso de una `lista`


## Tuplas y tipos de datos Numericos

Debemos de tener cuidado al momento que definimos una tupla con un único elemento de tipo numérico. Python puede llegar a interpretar los paréntesis como parte de la expresión matemática y definirlo como un tipo de dato numérico en lugar de una tupla.

```python
tupla = (4)

tupla

4

type(tupla)

int
```

Para solucionar esto, podemos hacer uso de la sintaxis (numero,)

```python
tupla = (4,)

tupla

(4,)

type(tupla)

tuple
```

## Packing y Unpacking - Empaquetado y Desempaquetado


Anteriormente pudimos ver como una `tupla` con varios elementos puede asignarse a una unica variable.

```python
mitupla = (1, 2, 3, 4)
```

No obstante, una `tupla` nos permite usar la estructura de `empaquetado` y `desempaquetado`. Esto quiere decir que podemos asignar los elementos de una `tupla` a distintas variables simultaneamente.


```python
mitupla = (1, 2, 3, 4)

print(mitupla)

(1, 2, 3, 4)

numero1, numero2, numero3, numero4 = mitupla
```

De modo que si ahora yo muestro las variables, corresponderan a los que teniamos en la `tupla`.

```python
print(numero1)

1

print(numero2)

2

print(numero3)

3

print(numero4)

4
```

> Una cosa a tener en cuenta es que al realizar este proceso, el numero de variables que pongamos deben de coincidir con el numero de elementos de la `tupla`


Ya que si asigno un valor menor o mayor, `python` me mostrara un error.

```python
numero1, numero2, numero3 = mitupla

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[7], line 2
      1 # El número de variables debe coincidir con el número de elementos de la tupla
----> 2 numero1, numero2, numero3 = tupla

ValueError: too many values to unpack (expected 3)
```

Este concepto de `desempaquetado` o `Unpacking` tambien nos permite devolver varios elementos en una función y asignarlos a varias variables.


```python
def funcion():

    return 1,2

func()

(1, 2)

numero1, numero2 = func()

print(numero1)

1

print(numero2)

2
```

Otra cosa a mencioanr que es bastante interesante es que podemos definir una tupla sin usar `()`. Es algo muy raro de `python` que quiza pueda causar confusión, por ello recomiendo siempre mantener buenas practicas y usar `()`


```python3
tupla = 1, 2, 3

type(tupla)

tuple
```

# Diccionarios [#](#diccionarios) {#diccionarios}

Los diccionarios son un tipo de dato complejo y particular en `Python` que corresponden con una colección de elementos `clave-valor`. Cada elemento `clave-valor` asocia la clave con un valor determinado.

Para representar los `diccionarios` dentro de python lo hacemos con el tipo de dato `dict`. La sintaxis utilizada para definir diccionarios es la siguiente: `{clave:valor1, clave2:valor2, ..., claven:valorn}`

Como podemos observar a diferencias de las listas y las tuplas usamos las `{}`

Veamos a continuación un ejemplo:

```python
diccionario = {
    "Nombre":"firtsmiracle",
    "Curso":"Python",
    "Idioma":"Español",
    "Nivel":"Todos los Niveles"
}
```

Como vemos los `diccionarios` nos permiten especificar un contexto sobre cada uno de los objetos, y de esta manera podemos tener una referencia de los objetos contenidos en la clave. 

Al imprimirlo tendriamos lo siguiente:

```python
print(diccionario)

{'Nombre': 'firtsmiracle', 'Curso': 'Python', 'Idioma': 'Español', 'Nivel': 'Todos los Niveles'}
```

y si le ahora usamos la función integrada `type` podemos ver que efectivamente nuestro dato corresponde a un `diccionario`

```python
type(diccionario)

dict
```

Ahora tambien existe una forma de definir un `diccionario`, aunque es un poco inusual. Para ellos la sisntaxis que debemos usar es definir una variable y usaremos la función `dict` que recibira una serie de argumentos que seran la `clave` y el `valor`. Pero esta vez la `clave` no sera declarada como un `string`, sino como un argumento y la igualamos al valor que queremos que tenga.

```pyhon
diccionario2 = dict(
    Nombre="firtsmiracle",
    Curso="Python",
    Idioma=Español",
    Nivel="Todos los Niveles"
)
```

Y si ahora sacamos este `diccionario` por pantalla, sera exactamente el mismo que definimos previamente.

```python
print(diccionario2)

{'Nombre': 'firtsmiracle', 'Curso': 'Python', 'Idioma': 'Español', 'Nivel': 'Todos los Niveles'}
```

## Acceso a los elementos de un Diccionario [#](#acceso-a-los-elementos-de-un-diccionario) {#acceso-a-los-elementos-de-un-diccionario}

A diferencia de las tuplas y las listas, en los diccionarios no podemos acceder utilizando un indice. Los valores se acceden utilizando el nombre de las `claves` entre `[]`.

Vemoslo nuevamente en un ejemplo a continuación, para ello usaremos el diccionario que previamente habiamos definido. 

```python
diccionario = {
    "Nombre":"firtsmiracle",
    "Curso":"Python",
    "Idioma":"Español",
    "Nivel":"Todos los Niveles"
}
```

Ahora supongamos que queremos acceder a la primera clave de mi diccionario. Lo que haria unicamente seria poner entre `[]` el nombre de la clave.

```python
diccionario['Nombre']

'firtsmiracle'
```

Lo mismo si quisieramos acceder a otra clave.

```python
diccionario['Curso']

'Python'
```

Sim embargo como antes mencionamos, que si queremos hacer lo mismo pero usando un indice, `python` nos dara un error, ya que nuevamente debemos recalcar que unicamente podemos acceder usando el nombre de las `claves`.


```python
diccionario[0]

---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-10-d5a2f4e83513> in <module>
----> 1 diccionario[0]

KeyError: 0
```

Otra cosa muy importante a tener en cuenta es que podemos usar cualquier objeto `inmutable` como clave de un `diccionario`. Estos incluyen a las listas, numeros, tuplas, strings entre otros.


```python
diccionario2 = {
    0: "numero cero",
    1: "numero uno",
    2: "numero dos",
    3: "numero tres"
}
```

Si ahora queremos acceder a uno de los valores tenemos que hacerlo a traves de su `clave`, que en este caso corresponde a un objeto `inmutable` que es un numero. Entonces debemos acceder de la siguiente forma:

```python
diccionario2[0]

'numero cero'
```

Lo mismo podriamos hacerlo pero esta vez usando un `tupla`.

```python
diccionario3 = {
    ("numero", 1): "primer numero",
    ("numero", 2): "segundo numero",
    ("numero", 3): "tercer numero"
}
```

Vemos que esta vez como clave usamos una `tupla`, y si queremos acceder a uno de los elementos pues debemos hacerlo a traves de la `tupla`. Raro pero podemos hacerlo.

```python
diccionario3[("numero", 1)]

'primer numero'
```


