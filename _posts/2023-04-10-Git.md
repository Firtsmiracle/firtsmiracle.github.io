---
layout      : post 
title       : "Git"
author      : Firtsmiracle
image       : assets/images/articles/2023-04-09-Git/git.png
category    : [ articles ]
tags        : [ Git, Repositorio ]
---

Hola en esta ocasión hablaremos de `Git` donde explicaremos paso a paso como funciona y el alcance que tiene que hace que sea necesario aprenderlo cuanto antes, asi que preparate por que debes aprender a usarlo a la de ya!.


## Indice y Estructura

- [Que es Git?](#que-es-git)
-  [Control de Versiones](#control-de-versiones)
- [Repositorio](#repositorio)
    * [Repositorio Local](#repositorio-local) 
    * [Repositorio Remoto](#repositorio-remoto) 
- [Commit - Comprometer](#commit-comprometer)
- [Instalación](#instalación)
- [Configuración](#configuración)
- [Creación del Repositorio](#creación-del-repositorio)
- [Areas de Git](#areas-de-git)
    * [Directorio de Trabajo - Working Directory ](#directorio-de-trabajo-working-direcotry)
    * [Area de Preparación - Staging Area](#area-de-preparación-staging-area)
    * [Repositorio .git - Repository .git](#repositorio-.git)
- [Estados de Git](#estados-de-git)
    * [Modificada - Modified](#modificada-modified)
    * [Preparada - Staged](#preparada-staged)
    * [Confirmada - Commited](#confirmada-commited)
- [Estado del Repositorio](#estado-del-repositorio)
- [Creación de un Commit](#creación-de-un-commit)
    * [Estructura del Commit](#estructura-del-commit)
    * [Historial de Commits](#historial-de-commits)
    * [Creación Alterna de Commits](#creación-alterna-de-commits)
    * [Cambiar Descripción del Commit](#cambiar-descripción-del-commit)
    * [Revertir Commits](#revertir-commits)
- [Branch - Ramas](#branch-ramas)
    * [Creación de un Branch](#creación-de-un-branch)
    * [Moverse de Branch](#moverse-de-branch)
    * [Cambiar Nombre al Branch](#cambiar-nombre-al-branch)
    * [Eliminar un Branch](#eliminar-un-branch)
    * [Crear Commits en un Branch](#crear-commits-en-un-branch)
    * [Historial de Commits en Branchs](#historial-de-commits-en-branchs)
- [Merge - Fusionar Branchs](#merge-fusionar-branchs)
    *  [Conflictos en Merge - Conflictos al fusionar branchs](#conflictos-en-merge-conflictos-al-fusionar-branchs)

## Que es Git? [#](#que-es-git) {#que-es-git}


Es un sistema de control de versiones que nos va a permitir rastrear todos lo cambios que hemos hecho en un conjunto de archivos.

## Control de Versiones [#](#control-de-versiones) {#control-de-versiones}

Viene a ser un sistema encargado de administrar los cambios que hemos realizado en un conjunto de  archivos o en programas de computadora.

## Repositorio [#](#repositorio) {#repositorio}

Es un conjunto o colección de archivos de distintas versiones de un proyecto.

Existen 2 tipos de de reposototios:

### Repositorio local [#](#repositorio-local) {#repositorio-local}


Es local cuando esta almacenado unicamente en la pc que lo creamos donde solo nosotros tendremos acceso  a el.


### Repositorio Remoto [#](#repositorio-remoto) {#repositorio-remoto}

Cuando queremos dar acceso a otros desarrolladores o colaboradores a nuestro repositorio o para tener una copia segura guardada en un servidor externo, creamos servidores remotos.

Ambos tipos de repositorios trabajan juntos ya que podemos crear una copia local de un repositorio remoto en nuestra pc como local y podemos enviar tambien el repositorio local que creamos a un repositorio remoto.

## Commit - Comprometer [#](#commit-comprometer) {#commit-comprometer}

Son un registro del estado de un proyecto en un momento especifico, a lo largo de la vida del proyecto.


Supongamos que creamos un archivo, editamos el archivo, creamos una carpeta y borramosel archivo: cada una de estas acciones vendria a ser un `commit`


![](/assets/images/articles/2023-04-09-Git/commits.PNG)


## Instalación [#](#instalación) {#instalación}

Para poder instalar `Git` si estamos en `windows` debemos ir a la pagina oficial para poder descargalo y al ejecutarlo solo debemos seguir los pasos por defecto:

* ![https://git-scm.com/downloads](https://git-scm.com/downloads)


En nuestro caso ya que trabajaremos en `linux` por ser mas comodo unicamente neceistamos ejecutar el comando `apt install git` y ya lo tendriamos instalado


En cuanto a lo demas todo es exactamente igual para cualquier sistema operativo en cuanto al desarrollo del curso despues de la instalación


## Configuración [#](#configuración) {#configuración}

Una vez tengamos ya instalado `Git` en nuestro sistema para comenzar a trabajar vamos a crear un directorio en un ruta de nuestro sistema.


En este caso creare el directorio `miGit` usando el comando `mkdir` y con `cd` ingresare al directorio

```bash
❯ mkdir miGit
❯ cd miGit
```

Ahora procederemos a configurar algo muy importante en `Git` que seria nuestro usuario y correo, ya que cada vez que creeemos un `commit` se registrara la información de quien realizo el cambio. Esto es util ya que si estamos trabajando en un proyecto colaborativo, cada uno de los desarrolladores del proyecto podran saber quien realizo ese cambio y cual es su correo asociado; de igual manera si solo nosotros estamos trabajando en el proyecto podemos saber en un futuro que cambio realizamos.


Para poder realizar la configuración del nombre de `usuario` solo debemos ejecutar el siguiente comando.


```bash
❯ git config --global user.name "Firtsmiracle"

```
cabe mencionar que si unicamente deseamos esta configuración para un unico proyecto debemos omitir el uso de la bandera `--global`, pero al ser nosotros dueños del repositorio es recomendable hacerlo globalmente.

Si queremos ver que los cambios se realizaron correctamente usamos:

```bash
❯ git config user.name
Firtsmiracle
```

De la misma manera si queremos configurar la información del `correo`, usamos el comando:

```bash
❯ git config --global user.email "firtsmiracle@hotmail.com"
```

volvemos a revisar si los cambios se guardaron exitosamente con el comando:

```bash
❯ git config user.email
firtsmiracle@hotmail.com
```

## Creación de Repositorio [#](#creación-del-repositorio) {#creación-del-repositorio}

Una vez tengamos configurado nuestro nombre de `usuario` y el `correo`, finalmente podemos continuar con lo mas fundamental de `Git`, que es la creación de un repositorio.

Primeramente debemos estar dentro de nuestra carpeta o directorio de trabajo en nuestro caso en la carpeta `miGit` con `pwd` verificamos que estemos en la ruta

```bash
❯ pwd
/home/fmiracle/Desktop/Prueba/Git/miGit
```

Para poder crear el repositorio dentro de esa carpeta debemos ejecutar el siguente comando `git init`

```bash
❯ git init
Inicializado repositorio Git vacío en /home/fmiracle/Desktop/Prueba/Git/miGit/.git/
```

Este comando nos inicializara un repositorio de `Git` dentro de esta carpeta y con ello vamos a poder rastrear las versiones de todos los archivos que esten dentro de esta carpeta.

Esto nos crea una carpeta de nombre `.git` que se encuentra oculta como medida de seguridad, si deseamos verla podemos usar el comando `ls -la`

```bash
❯ ls -la
drwxr-xr-x root root  8 B Mon Apr 10 17:38:01 2023  .
drwxr-xr-x root root 10 B Mon Apr 10 17:37:56 2023  ..
drwxr-xr-x root root 98 B Mon Apr 10 17:38:01 2023  .git
```

## Areas de Git [#](#areas-de-git) {#areas-de-git}

Existen tres areas en las cuales puede estar un archivo `Git`, donde cada una de ellas representara un estado distinto de un archivo.

![](/assets/images/articles/2023-04-09-Git/areas.PNG)

### Directorio de Trabajo - Working Directory [#](#directorio-de-trabajo-working-direcotry) {#directorio-de-trabajo-working-direcotry}

Es la carpeta del proyecto que justamente va a contener los archivos y el directorio oculto `.git`

### Area de Preparación - Staging Area [#](#area-de-preparación-staging-area) {#area-de-preparación-staging-area}

Viene a ser una area intermedia entre el `directorio del trabajo` y el `Repositorio`, aqui se encuentran los archivos y cambios que seran incluidos en el proximo `commit`

Cabe mencionar que esta area no es definitiva para agregarla al repositorio, ya que podemos evaluar y retractar los cambios que realizamos para que no se incluyan en el proximo `commit`

Cuando ya tenemos todos los cambios listo en el area de preparación, ahora si podemos crear un `commit` que sera el definitivo donde se encontraran los cambios que se agregaran al repositorio

### Repositorio .git [#](#repositorio-.git) {#repositorio-.git}

Aqui se contienen todos los metadatos y versiones de todo nuestro proyecto, es la parte del repositorio que se copia al clonar un repositorio externo en nuestra pc, concretamente cuando hacemos `git clone https://github.com/nombre_repo`

Es la parte mas importante de `Git`

## Estados de Git [#](#estados-de-git) {#estados-de-git}

Los archivos al estar en cada una de las areas mencionadas, repre/senta un estado distinto que podemos ver a continuación:

![](/assets/images/articles/2023-04-09-Git/Estados.PNG)

### Modificada - Modified [#](#modificada-modified) {#modificada-modified}

La versión del archivo esta `modificada`, si la versión contiene cambios que no son parte del repositorio y no se han añadido al `area de preparación`


### Preparada - Staged [#](#preparada-staged) {#preradara-staged}

La versión es `preparada`, cuando contiene cambios que no son parte del repositorio, pero si fue añadida al `area de preparación`

### Confirmada - Commited [#](#confirmada-commited) {#confirmada-commited}

La versión es `confirmada`, si ya se encuentra en el directorio `.git`

## Estado del Repositorio [#](#estado-del-repositorio) {#estado-del-repositorio}

Para poder verificar el estado de nuestro repositorio podemos hacer uso del comando `git status`

```bash
❯ git status
En la rama main

No hay commits todavía

no hay nada para confirmar (crea/copia archivos y usa "git add" para hacerles seguimiento)
```

Despues de ejecutar el comando nos muestra que estamos en la rama `main`, que aun no hemos realizado un `commit` y ademas vemos que tampoco hay nada pendiente para realizar un `commit`


> Cabe mencionar que segun la instalación nuestra rama principal puede ser `main` o `master` y si deseamos cambiarla debemos ejecutar el comando `git config --global init.defaultBranch main` para establecer `main` como la rama principal por defecton, aunque de seguir con la que tenemos por defecto podemos trabajar sin problemas igualmente, pero hay que tenerlo en cuenta


Ahora que ocurre si yo creo un archivo lo llamaremos `archivo_git.txt` y le introduciremos un contenido.

```bash
❯ /bin/cat archivo_git.txt
Este es mi primer repositorio
```
Si volvemos a ejecutar el comando `git status`, esta vez nos dice que tenemos archivos que no estamos haciendo seguimiento, concretamente el archivo que creamos `archivo_git.txt` 
```bash
❯ git status
En la rama main

No hay commits todavía

Archivos sin seguimiento:
  (usa "git add <archivo>..." para incluirlo a lo que se será confirmado)
	archivo_git.txt

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
```

Si queremos comenzar a hacer seguimiento del arhivo, debemos ejecutar el comando `git add` y seguido el nombre del archivo

```bash
❯ git add archivo_git.txt
```
A simple vista parece no haberse ejecutado ningun cambio pero si volvemos a verificar el estado con `git status`,  ahora si tenemos cambios que van a ser agregados al proximo `commit`

```bash
❯ git status
En la rama main

No hay commits todavía

Cambios a ser confirmados:
  (usa "git rm --cached <archivo>..." para sacar del área de stage)
	nuevos archivos: archivo_git.txt
```

Cuando vemos que el archivo ya es parte de los cambios que se agregaran a el proximo `commit`, quiere decir que ya es parte del `area de preparación`, pero recordemos que en esta area aun podemos retractarnos y decir a `Git` que no queremos agregarlos al proximo `commit`, y esto lo hacemos como nos indica `Git` con el comando `git rm --cached` y seguidamente el nombre del archivo.

```bash
❯ git rm --cached archivo_git.txt
rm 'archivo_git.txt'
```

Volvemos a verificar el estado y vemos que el archivo nuevamente no esta en seguimiento.

```bash
❯ git status
En la rama main

No hay commits todavía

Archivos sin seguimiento:
  (usa "git add <archivo>..." para incluirlo a lo que se será confirmado)
	archivo_git.txt

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
```

Saber esto es importante ya que en el `area de preparación` los cambios no son definitivos, ya que podemos equivocarnos y por error incluir un archivo al `area de preparación`podemos verificar que cambios seran agregados y si queremos removerlos del `area de preparación`


Ahora si queremos volver a colocar el archivo en el area de `preparación`, usamos nuevamente el comando `git add` y nuevamente vemos que hay cambios que seran agregados al proximo `commit`

```bash
❯ git add archivo_git.txt
❯ git status
En la rama main

No hay commits todavía

Cambios a ser confirmados:
  (usa "git rm --cached <archivo>..." para sacar del área de stage)
	nuevos archivos: archivo_git.txt
```

Lo que faltaria ahora sera pasar el archivo del `area de preparación` al repositorio como tal `.git` para ello veamos a continuaciòn como creamos un `commit`


## Creación de un Commit [#](#creación-de-un-commit) {#creación-de-un-commit}

Antes de crear nuestro primer `commit`, debemos recordar que un `commit` viene a ser un registro o foto del estado de nuestro proyecto en un momento especifico. Registra los cambios realizados en los archivos en comparación con la versión anterior.


![](/assets/images/articles/2023-04-09-Git/commits.PNG)

Cada vez que creeemos un `commit` debemos agregarle una descripción segun la acción o los cambios que hayamos realizado esto es muy importante para saber con detalle a traves del tiempo las modificaciones que se realizaron en el proyecto.


Ahora comenzemos a crear nuestro `commit`

Anteriormente cuando ejecutamos `git status`, veiamos que habian cambios que estan listos para ser agregados del `area de preparación` a al repositorio `.git`.

```bash
❯ git status
En la rama main

No hay commits todavía

Cambios a ser confirmados:
  (usa "git rm --cached <archivo>..." para sacar del área de stage)
	nuevos archivos: archivo_git.txt
```

Lo siguiente seria agregar un `commit`, esto lo hacemos con el comando `git commit` y seguidamente con `-m` agregamos una descripción.


```bash
❯ git commit -m "agregar mi archivo de texto"
[main (commit-raíz) 0143452] agregar mi archivo de texto
 1 file changed, 1 insertion(+)
 create mode 100644 archivo_git.txt
```
Se nos muestra información del `commit`, como su identificador `0143452`, la descripción y hubo una modificación en conjunto con una inserción que significa que se agrego una linea al archivo.


## Estructura del Commit [#](#estructura-del-commit) {#estructura-del-commit}

La estructura de un`commit` se compone de varias partes, esto lo observamos al ejecutar el comando `git log`.

```bash
❯ git log
commit 0143452c010ede2332f5c1b8bad7815743770a2a (HEAD -> main)
Author: Firtsmiracle <firtsmiracle@hotmail.com>
Date:   Mon Apr 10 18:43:50 2023 +0000

    agregar mi archivo de texto
```

Podemos observar inicialmente una serie de numeros alfanumericos que corresponde a un identificador unico llamado `SHA`.

> SHA: Scure Hash Algorith o Algoritmo de hash seguro

este `SHA` identifica:

* Los cambios realizados
* Dónde se realizaron los cambios
* Quién realizo los cambios


Seguidamente el `commit` contiene el nombre del `usuario` en conjunto con el `correo` asignado `Author: Firtsmiracle <firtsmiracle@hotmail.com>`; tambien podemos observar la fecha de creación del `commit` que corresponde a `Date:   Mon Apr 10 18:43:50 2023 +0000`


Finalmente en la ultima parte podemos ver la descripción que agregamos al crear nuestro `commit` -> `agregar mi archivo de texto`


## Historial de Commits [#](#historial-de-commits) {#historial-de-commits}

Si queremos ver el registro de nuestros `commits`, podemos usar el comando `git log` el cual nos mostrara el historial de todos los `commits` que hayamos creado.


```bash
❯ git log
commit 0143452c010ede2332f5c1b8bad7815743770a2a (HEAD -> main)
Author: Firtsmiracle <firtsmiracle@hotmail.com>
Date:   Mon Apr 10 18:43:50 2023 +0000

    agregar mi archivo de texto
```

Como vimos anteriormente vemos el `commit` con su estructura; cabe resaltar que si creamos mas `commits` con este comandos los veremos todos.


## Creación Alterna de Commits [#](#creación-alterna-de-commits) {#creación-alterna-de-commits}

Supongamos que editamos el archivo que tenemos `archivo_git.txt` y le cambiamos el contenido 

El cual cambiaremos de este contenido:

```bash
❯ /bin/cat archivo_git.txt
Este es mi primer repositorio
```

a este nuevo

```bash
❯ /bin/cat archivo_git.txt
Este es mi segundo commit
```

Si ejecutamos `git status` vemos que tenemos un archivo en estado `modificado` y que hay cambios no rastreados para el proximo `commit` 

```bash
❯ git status
En la rama main
Cambios no rastreados para el commit:
  (usa "git add <archivo>..." para actualizar lo que será confirmado)
  (usa "git restore <archivo>..." para descartar los cambios en el directorio de trabajo)
	modificados:     archivo_git.txt

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
```

Para agregar los cambios entonces debemos ejecutar `git add`

```bash
❯ git add archivo_git.txt
❯ git status
En la rama main
Cambios a ser confirmados:
  (usa "git restore --staged <archivo>..." para sacar del área de stage)
	modificados:     archivo_git.txt
```

Ahora que el archivo esta lista para agregarse al `commit`, procerederemos a crearlo

Esta vez ejecutaremos unicamente el comando `git commit` sin ningun parametro adiocional, lo que hara que se nos abra el editor de texto donde podremos insertar la descripción ddel `commit`


Generalmente se nos abrira el editor por defecto en nuestro sistema en nuestro caso por defecto se abrira en `vim` o `nano`, pero si deseamos podemos configurar el editor apra que inicie con otro con el que trabajemos mas comodo.


Para ello hay varias opciones independientemente si nos encontramos en `Linux` o en `Windows`


Para `Linux`:

Si queremos usar `Visual Studio Code` ejecutar:

```bash
$ git config --global core.editor "code --wait"
```

Si queremos usar `Sublime Text` ejecutar:

```bash
$ git config --global core.editor "subl -n -w"
```

Si queremos usar `emacs` ejecutar: 

```bash
git config --global core.editor emacs
```

Para `Windows`:

Si queremos usar `Visual Studio Code` ejecutar:

```bash
$ git config --global core.editor "code --wait"
```

Si queremos usar `Sublime Text` ejecutar:

```bash
$ git config --global core.editor "'C:/Program Files (x86)/sublime text 3/subl.exe' -w"
```

Si queremos usar `Notepad++` ejecutar:

```bash
$ git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
```

Entonces una vez tengamos configurado nuestro editor procedemos a ejecutar `git commit` y se procedera a abrirnos nuestro editor de texto. Tal y como nos indicar podemos agregar un mensaje del `commit` en una linea sin comentar y guardamos los cambios, pero si deseamos cancelar la operación simplemente el mensaje tiene que estar vacio.

```bash

# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# En la rama main
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

Entonces vamos a agregar un mensaje para el `commit`

```bash
Cambiar texto a segundo commit
# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# En la rama main
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

y automaticamente al guardar y cerrar el archivo, procede a crearse el `commit`

```bash
❯ git commit
[main bb00766] Cambiar texto a segundo commit
 1 file changed, 1 insertion(+), 1 deletion(-)
```

Ahora podemos volver a ver el historial de `commits` usando `git log` y esta vez vemos los dos `commits`

```bash
❯ git log
commit bb007665d2356b9531ce10be913fd26a27e757da (HEAD -> main)
Author: Firtsmiracle <firtsmiracle@hotmail.com>
Date:   Mon Apr 10 20:13:55 2023 +0000

    Cambiar texto a segundo commit

commit 0143452c010ede2332f5c1b8bad7815743770a2a
Author: Firtsmiracle <firtsmiracle@hotmail.com>
Date:   Mon Apr 10 18:43:50 2023 +0000

    agregar mi archivo de texto
```

## Cambiar Descripción del Commit [#](#cambiar-descripción-del-commit) {#cambiar-descripción-del-commit}

Supongamos que creamos un `commit`, pero vimos que pudimos tener un error de tipeo o el mensaje no es muy descriptivo. Pues podemos modificar el ultimo `commit` usando el comando `git commit --amend`

```bash
❯ git commit --amend
```

Al ejecutar se nos vuelve a abrir el editor de texto con la descripción que habiamos ingresado

```bash
Cambiar texto a segundo commit

# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# Fecha:     Mon Apr 10 20:13:55 2023 +0000
#
# En la rama main
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

Para modificarlo solo debemos modificar el mensaje, guardar y cerrar el archivo.

```bash
Cambiar el contenido de mi commit

# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# Fecha:     Mon Apr 10 20:13:55 2023 +0000
#
# En la rama main
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

Regresamos a donde ejecutamos el comando y vemos que se actualizo correctamente.

```bash
❯ git commit --amend
[main 222c488] Cambiar el contenido de mi commit
 Date: Mon Apr 10 20:13:55 2023 +0000
 1 file changed, 1 insertion(+), 1 deletion(-)
```

Para verificar que se actualizo el `commit` en el historial usamos `git log`, pero esta vez agregaremos el parametro `--oneline` para acortar la información mostrada.

```bash
❯ git log --oneline
222c488 (HEAD -> main) Cambiar el contenido de mi commit
0143452 agregar mi archivo de texto
```

Y vemos que fue modificado con exito.


> Es importante saber que si vamos a ejecutar el comando `git commit --amend` lo hagamos en nuestro `repositorio local` no en uno remoto ya que puede ser riesgoso si lo hacemos en proyectos que ya estan siendo usados por otros desarrolladores.


Como consejo hay que tratar siempre de ingresar la descripción o mensaje correcto al `commit` para evitar realizar este proceso


## Revertir Commits [#](#revertir-commits) {#revertir-commits}

Suele pasar en ocasiones cuando estamos trabajando en algun proyecto y al crear un `commit` nos damos cuenta de que nos faltaba agregar algo. Si queremos revertir los cambios hechos por un `commit`, podemos hacerlo de forma tal que no se afecten los archivos.


Para realizar esto el comando que debemos ejecutar es `git reset --soft HEAD~1`, donde con el parametro `soft` podemos reiniciarlo de modo que los archivos no se modifiquen en el directorio de trabajo. Solo se va a deshacer el registro del `commit`, en este caso con `HEAD~1` indicaremos al ultimo `commit` que se realizo.

```bash
❯ git reset --soft HEAD~1
```

Una vez ejecutamos el comando, visiblemente no vemos ningun cambio, pero si volvemos a ver el historial de `commits`, solo vemos el primer `commit`

```bash
❯ git log
commit 0143452c010ede2332f5c1b8bad7815743770a2a (HEAD -> main)
Author: Firtsmiracle <firtsmiracle@hotmail.com>
Date:   Mon Apr 10 18:43:50 2023 +0000

    agregar mi archivo de texto
```

Y si volvemos a leer el archivo, aún mantiene el contenido con los cambios que habiamos realizado

```bash
❯ /bin/cat archivo_git.txt
Este es mi segundo commit
```

Pero que pasa si volvemos a modificar el archivo 

```bash
❯ /bin/cat archivo_git.txt
Este es mi segundo commit pero modificado
```
º
y volvemos a ejecutar `git status`, vemos cambios listos para ser agregados y otros que aun no estan listos.

```bash
❯ git status
En la rama main
Cambios a ser confirmados:
  (usa "git restore --staged <archivo>..." para sacar del área de stage)
	modificados:     archivo_git.txt

Cambios no rastreados para el commit:
  (usa "git add <archivo>..." para actualizar lo que será confirmado)
  (usa "git restore <archivo>..." para descartar los cambios en el directorio de trabajo)
	modificados:     archivo_git.txt
```

Como deshicimos el ultimo `commit` lo que quiere decir que el cambio a de ese ultimo `commit` que borramos, aún no es parte del repositorio. Para agregar todos esos cambios lo que podemos hacer es ejecutar el comando `git add .`

> Con `git add .` podemos agregar todos los cambios al `area de preparación`, sin necesidad de ejecutar cada archivo.

```bash
❯ git add .
❯ git status
En la rama main
Cambios a ser confirmados:
  (usa "git restore --staged <archivo>..." para sacar del área de stage)
	modificados:     archivo_git.txt
```

Ahora si queremos crear este `commit`, volvemos a ejecutar `git commit` y asignamos un mensaje mas especifico

```bash
Actualizar teto del segundo commit modificado
# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# En la rama main
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

Guardamos y cerramos y ya tendriamos creado este nuevo `commit`

```bash
❯ git commit
[main 415796f] Actualizar teto del segundo commit modificado
 1 file changed, 1 insertion(+), 1 deletion(-)
```

## Branch - Ramas [#](#branch-ramas) {#branch-ramas}

Un `branch` es una linea independiente de desarrollo en el repositorio, gracias a estas podemos tener copias del `branch` principal y que estas vallan evolucionando o cambiando independientemente sin afectar al `branch` principal.

El concepto es similar a las ramas de un arbol, donde tenemos como branch o rama principal `main` o `master` y desde ahi podemos crear otras subramas que en algun  momento si queremos podemos convinar.

![](/assets/images/articles/2023-04-09-Git/ramas.PNG)

Supongamos que tenemos una linea actual del proyecto, pero queremos agregarle nuevas funcionalidades como una nueva sección o cambiar algo para ver su funcionamiento. Pues si creamos un nuevo `branch` podemos realizar nuestros cambios sin afectar la versión que actualmente este activo.

Una vez que el `branch` alterno a evolucionado con todos los cambios correspondientes, podemos combinarla con el `branch` principal.


### Creación de un Branch [#](#creación-de-un-branch) {#creación-de-un-branch}

Para poder crear un nuevo `branch` debemos ejecutar el comando `git branch` y seguidamente el nombre de la rama que queremos crear


```bash
❯ git branch primer-branch-alterno
```
y ahora para visualizar los `branch` que tenemos usamos unicamente el comando `git branch`

```bash
❯ git branch
* main
  primer-branch-alterno
```

El comandos nos muestra que ahora tenemos dos `branch`, el principal que teniamos `main` y ahora el nuevo que creamos `primer-branch-alterno`

### Moverse de Branch [#](#moverse-de-branch) {#moverse-de-branch}

Si queremos desplazarnos de un `branch` a otro debemos ejecutar el comando `git checkout` y seguido el nombre del `branch`


```bash
❯ git checkout primer-branch-alterno
Cambiado a rama 'primer-branch-alterno'
```

Para confirmar que nos cambiamos a ese nuevo `branch` volvemos a ejecutar `git branch` y esta vez nos selecciona el `branch` alterno

```bash
❯ git branch
  main
* primer-branch-alterno
```

Ahora existe una forma de agilizar este proceso de creación y desplazamiento de un `branch` para ello debemos ejecutar `git checkout -b` y seguido el nombre de la rama. Pero es importante antes de ejecutar el comando volver a nuestro `branch` original `main` ya que nos encontramos en el `branch` `primer-branch-alterno` y nosotros queremos crear el `branch` a partir de el `branch` principal.


```bash
❯ git checkout main
Cambiado a rama 'main'
```

y ahora si podemos ejecutar el comando y visializamos que efectivamente nos encontramos en el nuevo `branch`

```bash
❯ git checkout -b segundo-branch-alterno
Cambiado a nueva rama 'segundo-branch-alterno'
❯ git branch
  main
  primer-branch-alterno
* segundo-branch-alterno
```

### Cambiar Nombre al Branch [#](#cambiar-nombre-al-branch) {#cambiar-nombre-al-branch}

Para cambiar el nombre de un `branch` existen dos metodos:


En el primero debemos estar en el `branch` que deseamos cambiar el nombre, para este caso queremos cambiar el nombre de `primer-branch-alterno` a `primer-branch` y ejecutar el comando `git branch -m` y seguidamente el nuevo nombre a asignar.

```bash
❯ git checkout primer-branch-alterno
Cambiado a rama 'primer-branch-alterno'
git branch -m primer-branch
```
Verificamos los cambios usando `git branch`y efectivamente nos modifico el nombre

```bash
❯ git branch
  main
* primer-branch
  segundo-branch-alterno
```

Si queremos usar el segundo metodo no es necesario estar en el `branch` que deseamos cambiar, tan solo hay que ejecutar `git branch -m`, seguidamente el nombre del `branch` que deseamos cambiar `segundo-branch-alterno` y despues el nuevo nombre que se le asignara `segundo-branch`

```bash
❯ git branch -m segundo-branch-alterno segundo-branch
❯ git branch
  main
* primer-branch
  segundo-branch
```
### Eliminar un Branch [#](#eliminar-un-branch) {#eliminar-un-branch}

Una vez que combinamos los cambios que realizamos en los `branchs` o si las creamos por error, podemos eliminarlos.

Si deseamos eliminar el `branch`, hay que ejecutar el comando `git branch -d` y seguidamente el nombre del `branch` que queramos borrar.

```bash
❯ git branch -d segundo-branch
Eliminada la rama segundo-branch (era 415796f).
❯ git branch
```

Verificamos si se realizaron los cambios y se borro el `branch` con exito.

```bash
❯ git branch
  main
* primer-branch
```
> Este comando aplica a `branch` en repositorios locales no en `branch` que se encuentren publicadas.

### Crear Commits en un Branch [#](#crear-commits-en-un-branch) {#crear-commits-en-un-branch}

Veamos como podemos crear un `commit` en un `branch` que no sea `main` que nosotros creemos y veremos como podemos cambiar entre estos `branch` para ver como nuestros archivos cambian en nuestros directorios de trabajo.

Esta parte es excelente, paece magia negra xD!

Bueno sabemos que tenemos un archivo de texto en nuestro directorio llamado `archivo_git.txt` con un cotenido asignado.

```bash
❯ ls
 archivo_git.txt
❯ /bin/cat archivo_git.txt
Este es mi segundo commit pero modificado
```
Ahora nos encontramos en nuestro `branch` principal `main`

```bash
❯ git branch
* main
  primer-branch
```

Primero para realizar un cambio nos vamos a mover a nuestro `branch` alterno `primer-branch`

```bash
❯ git checkout primer-branch
Cambiado a rama 'primer-branch
```
Una vez nos en este `branch` leemos el archivo que tenemos.

```
❯ /bin/cat archivo_git.txt
Este es mi segundo commit pero modificado
```

Podemos ver que el contenido es el mismo, entonces ahora vamos a modificarlo.

```bash
❯ /bin/cat archivo_git.txt
Hola Git
```
Veamos ahora que ocurre si ejecutamos `git status`

```bash
❯ git status
En la rama primer-branch
Cambios no rastreados para el commit:
  (usa "git add <archivo>..." para actualizar lo que será confirmado)
  (usa "git restore <archivo>..." para descartar los cambios en el directorio de trabajo)
	modificados:     archivo_git.txt

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
```
Nos muestra que estamos en el `branch` alterno `primer-branch` y que tenemos cambios que aún no han sido preparados para el proximo `commit`. Entonces para agregsarlo ejecutamos el comando `git add .` para agregarlos.


```bash
❯ git add .
❯ git status
En la rama primer-branch
Cambios a ser confirmados:
  (usa "git restore --staged <archivo>..." para sacar del área de stage)
	modificados:     archivo_git.txt
```
Esta vez aun estamos en el `branch` alterno `primer-branch`, pero si tenemos el archivo en el `area de preparación`.

Procedemos a crear nuestro `commit` con `git commit` y se nos abre nuestro editor de texto, en el cual introduciremos la descripción de este nuevo `commit`

```bash
Cambiar texto a Hola Git
# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# En la rama primer-branch
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```
Guardamos y cerramos el editor y tendriamos un nuevo `commit`

```bash
❯ git commit
[primer-branch 9771c56] Cambiar texto a Hola Git
 1 file changed, 1 insertion(+), 1 deletion(-)
```

Vamos a leer el archivo otra vez, recordar que estamos en el `branch` alterno `primer-branch`

```bash
❯ /bin/cat archivo_git.txt
Hola Git
```

efectivamente vemos los cambios que realizamos, pero que pasa si ahora vamos a nuestro `branch` principal `main`

```bash
❯ git checkout main
Cambiado a rama 'main'
```

Una vez aqui voy a leer mi archivo `archivo_git.txt`

```bash
❯ /bin/cat archivo_git.txt
Este es mi segundo commit pero modificado
```

y pumm! wala!! se tenso la cosa, tenemos el contenido antes de realizar el `commit` en el `branch` alterno. Esto es super genial por que estamos trabajando con el mismo archivo, pero con dos versiones diferentes :).

 
### Historial de Commits en Branchs [#](#historial-de-commits-en-branchs) {#historial-de-commits-en-branchs}

Primeramente vamos a ejecutar el comando `git log` con el parametro `--oneline` para acortar la información.

```bash
❯ git log --oneline
415796f (HEAD -> main) Actualizar teto del segundo commit modificado
0143452 agregar mi archivo de texto
```
Podemos ver el historial de `commits` en `main`, pero no vemos el `commit` que realizamos en el `branch` alterno `primer-branch`

Vamos a irnos a el `branch` alterno con `git checkout`

```bash
❯ git log --oneline
9771c56 (HEAD -> primer-branch) Cambiar texto a Hola Git
415796f (main) Actualizar teto del segundo commit modificado
0143452 agregar mi archivo de texto
```
Nos damos cuenta que ambos `branch` comparten los ultimos dos `commits`, pero despues al crearse el `branch` alterno el primer `commit` que se creo fue el primero. Por eso este `branch` muestra este nuevo `commit` y el `branch` principal `main` no, ya que el primer `commit` pertener a este nuevo `branch`

> Debo mencionar que existe un comando el cual muestra los `commit` y cual fue la diferencia que introdujo el `commit`

```bash
❯ git log -p
commit 9771c563effc6eb6a82ed94947c125fdbdd03233 (HEAD -> primer-branch)
Author: Firtsmiracle <firtsmiracle@hotmail.com>
Date:   Mon Apr 10 21:46:43 2023 +0000

    Cambiar texto a Hola Git

diff --git a/archivo_git.txt b/archivo_git.txt
index cf36484..0152d71 100644
--- a/archivo_git.txt
+++ b/archivo_git.txt
@@ -1 +1 @@
-Este es mi segundo commit pero modificado
+Hola Git
```

### Merge - Fusionar Branchs [#](#merge-fusionar-branchs) {#merge-fusionar-branchs}

Ya que los `branchs` son temporales, debido a que existen miestras estamos desarrollando alguna funcionalidad o corrigiendo un problema, llegara un momento en que debamos fusionar esos cambios con el `branch` principal, este proceso se denomina `merge`

> Para fusionar dos `branch` es muy importante estar en el `branch` que recibira la fusión.

Para ello vamos a practicar lo anteriormente aprendido.

Primero voy a dirigirme a el `branch` principal `main`

```bash
❯ git checkout main
Cambiado a rama 'main'
❯ git branch
* main
  primer-branch
```

Ahora crearemos un nuevo `branch` y nos metemos en el

```bash
❯ git checkout -b segundo-branch
Cambiado a nueva rama 'segundo-branch'
❯ git branch
  main
  primer-branch
* segundo-branch
```

Vamos a modificar el archivo `archivo_git.txt`

```bash
❯ /bin/cat archivo_git.txt
Hola Git
Ahora estoy aprendiendo Git
```

Continuamos verificado el estadoy vemos que fue modificado

```bash
❯ git status
En la rama segundo-branch
Cambios no rastreados para el commit:
  (usa "git add <archivo>..." para actualizar lo que será confirmado)
  (usa "git restore <archivo>..." para descartar los cambios en el directorio de trabajo)
	modificados:     archivo_git.txt

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
```

Sigue agregarlo al area de preparación

```bash
❯ git add .
❯ git status
En la rama segundo-branch
Cambios a ser confirmados:
  (usa "git restore --staged <archivo>..." para sacar del área de stage)
	modificados:     archivo_git.txt
```

Creamos el `commit` con `git commit`

```bash
Agregamos una segunda linea al archivo
# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# En la rama segundo-branch
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

Guardamos y cerramos

```bash
❯ git commit
[segundo-branch 924f1c5] Agregamos una segunda linea al archivo
 1 file changed, 2 insertions(+), 1 deletion(-)
```

Ahora volveremos a el `branch` principal `main` y vemos el antiguo contenido.

```bash
❯ /bin/cat archivo_git.txt
Este es mi segundo commit pero modificado
```

Para poder realizar ahora el `merge` o la fusión de `branch`, despues de ya terminar de hacer todos nuestros cambios. Debemos estar en el `branch` que recibira los cambios.

```bash
❯ git branch
* main
  primer-branch
  segundo-branch
```

Y ahora procedemos a ejecutar el comando `git merge` seguido de el nombre de la rama que queremos fusionar, en nuesto caso queremos fusionar el `branch` recien creado `segundo-branch`

```bash
❯ git merge segundo-branch
Actualizando 415796f..924f1c5
Fast-forward
 archivo_git.txt | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
```
Vemos el mensaje de que se estan combinando todos los `commits` con el `branch` principal

Y ahora si leemos el archivo `archivo_git.txt`, vemos que se combinaron ambos `branch` :)

```bash
❯ /bin/cat archivo_git.txt
Hola Git
Ahora estoy aprendiendo Git
```

y si vemos el historial ahora ese `commit` que hicimos al modificar el archivo en `segundo-branch`, tambien es parte de `main`

```bash
❯ git log --oneline
924f1c5 (HEAD -> main, segundo-branch) Agregamos una segunda linea al archivo
415796f Actualizar teto del segundo commit modificado
0143452 agregar mi archivo de texto
```

### Conflictos en Merge - Conflictos al fusionar Branchs [#](#conflictos-en-merge-conflictos-al-fusionar-branchs) {#conflictos-en-merge-conflictos-al-fusionar-branchs}

Ya que realizamos antes el `merge` de ambos `branch`, no necesitamos ya el `branch` que creamos `segundo-branch`

```bash
❯ git branch
* main
  primer-branch
  segundo-branch
```

Asi que podemos borrar este `branch`

```bash
❯ git branch -d segundo-branch
Eliminada la rama segundo-branch (era 924f1c5).
```

Ahora los conflictos ocurren cuando tratamos de hacer un `merge` de archivos que tienen cambios que tienen conflictos.

Estos pueden ser: Modificar el mismo texto, Modificar la misma linea o elemento, esto `Git` los considera incompatible.

En estos casos tenemos que decidir como vamos a hacer el `merge`

Veamoslo a continuación:

Vemos que el contenido del archivo en `primer-branch` es

```bash
❯ git branch
  main
* primer-branch
❯ /bin/cat archivo_git.txt
Hola miGit
```
y ahora si vamos a `main` y leemos el archivo

```bash
❯ git checkout main
Cambiado a rama 'main'
❯ /bin/cat archivo_git.txt
Hola Git
Ahora estoy aprendiendo Git
```

Que pasa si intentamos hacer un `merge` de ambos `branch`

```bash
❯ git merge primer-branch
Auto-fusionando archivo_git.txt
CONFLICTO (contenido): Conflicto de fusión en archivo_git.txt
Fusión automática falló; arregle los conflictos y luego realice un commit con el resultado.
```

Al ejecutar el comando, nos dice que la combinación automatica falló y debemos arreglar los conflictos.

Si vamos a nuestro editor de texto nos mostrara algo de este tipo

```bash
<<<<<<< HEAD
Hola Git
Ahora estoy aprendiendo Git
=======
Hola miGit
>>>>>>> primer-branch
```

En este caso el editor de texto `Visual Studio Code`, nos fascilita decidir cuando tenemos este tipo de conflictos. Asi que en estos casos es muy recomendable usarlo.

Nos da las opciones: 

* `Accept Current Change` : Aceptar el cambio actual "del branch main"
* `Accept Incoming Change` : Aceptar el cambio entrante "del branch primer-branch"
* `Accept Both Change` : Aceptar ambos cambios
* `Compare changes` : Comparar los cambios

![](/assets/images/articles/2023-04-09-Git/code1.PNG)


Esa decisión ya dependera del cambio que estes dispuesto a aceptar.

En este caso usare la opción de aceptar ambos cambios.

![](/assets/images/articles/2023-04-09-Git/code2.PNG)

Continuamos guardando y cerrando el editor y ejecutamos `git merge --continue` para continuar el proceso de fusión, esto nos abrira el editor nuevamente con el mensaje que se asignara al `commit`

```bash
Merge branch 'primer-branch'

# Conflicts:
#	archivo_git.txt
#
# Parece que estás realizando una fusión.
# Si esto no es correcto, ejecuta
#	git update-ref -d MERGE_HEAD
# e intenta de nuevo.


# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# En la rama main
# Todos los conflictos resueltos pero sigues fusionando.
#
# Cambios a ser confirmados:
#	modificados:     archivo_git.txt
#
```

Guardamos el archivo y cerramos para culminar el proceso

```bash
❯ git merge --continue
[main 95b5d86] Merge branch 'primer-branch'
```

Pudimos solucionar el conflicto y nos hizo el `merge` de manera exitosa, como vimos en este caso `visual studio code` es muy útil para solucionar estos conflictos.

Ahora finalmente leeremos el archivo otra vez

```bash
❯ /bin/cat archivo_git.txt
Hola Git
Ahora estoy aprendiendo Git
Hola miGit
```

Y como resultado tenemos el archivo tal y cual lo combinamos :).
